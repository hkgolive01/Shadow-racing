<!DOCTYPE html>
<html lang="zh-HK">

<head>
    <meta charset="UTF-8">
    <title>Shadow Racing - Ultimate Edition</title>
    <script src="https://html2canvas.hertzen.com/dist/html2canvas.min.js"></script>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=sans-serif:wght@400;700;900&family=Roboto:wght@400;700;900&display=swap');

        body {
            background-color: #050505;
            color: #ecf0f1;
            font-family: 'Roboto', sans-serif;
            display: flex;
            flex-direction: column;
            height: 100vh;
            margin: 0;
            overflow: hidden;
            user-select: none;
        }

        /* --- UI BAR --- */
        #ui-bar {
            height: 140px;
            background: #0b0b0b;
            border-bottom: 2px solid #333;
            display: flex;
            justify-content: space-between;
            align-items: flex-start;
            padding: 10px 30px 0 30px;
            box-shadow: 0 5px 20px rgba(0, 0, 0, 0.9);
            z-index: 10;
            flex-shrink: 0;
        }

        .center-display {
            text-align: center;
            width: 200px;
            margin-top: 10px;
        }

        #timer-display {
            font-family: 'Roboto', sans-serif;
            font-size: 70px;
            color: #fff;
            text-shadow: 0 0 15px rgba(255, 255, 255, 0.4);
            line-height: 1;
        }

        .timer-label {
            font-size: 14px;
            color: #666;
            letter-spacing: 2px;
            margin-top: 5px;
        }

        .player-info {
            display: flex;
            flex-direction: column;
            width: 380px;
            font-family: 'Roboto', sans-serif;
            position: relative;
            transition: color 0.3s, border-color 0.3s;
        }

        .p1-info {
            border-left: 4px solid;
            padding-left: 20px;
        }

        .p2-info {
            border-right: 4px solid;
            padding-right: 20px;
            text-align: right;
            align-items: flex-end;
        }

        .input-group {
            display: flex;
            align-items: center;
            gap: 10px;
            margin-bottom: 2px;
            flex-wrap: wrap;
        }

        .p2-info .input-group {
            flex-direction: row-reverse;
        }

        .name-input {
            background: transparent;
            border: 1px solid transparent;
            color: inherit;
            font-family: 'Roboto', sans-serif;
            font-size: 20px;
            font-weight: bold;
            width: 150px;
            padding: 2px 0;
            border-radius: 4px;
            outline: none;
            transition: 0.2s;
        }

        .name-input:hover {
            border-color: #333;
            cursor: pointer;
        }

        .name-input:focus {
            border-color: #fff;
            background: #222;
            cursor: text;
        }

        .p2-info .name-input {
            text-align: right;
        }

        .color-picker {
            -webkit-appearance: none;
            border: none;
            width: 20px;
            height: 20px;
            cursor: pointer;
            background: none;
            padding: 0;
        }

        .color-picker::-webkit-color-swatch-wrapper {
            padding: 0;
        }

        .color-picker::-webkit-color-swatch {
            border: 2px solid #555;
            border-radius: 50%;
        }

        .ai-label {
            display: flex;
            align-items: center;
            gap: 5px;
            font-size: 12px;
            font-weight: bold;
            color: #888;
            cursor: pointer;
            border: 1px solid #333;
            padding: 2px 6px;
            border-radius: 4px;
            transition: 0.2s;
        }

        .ai-label:hover {
            border-color: #666;
            color: #fff;
        }

        .ai-checkbox {
            cursor: pointer;
        }

        .ai-hidden {
            display: none !important;
        }

        .stats-row-composite {
            display: flex;
            align-items: baseline;
            gap: 25px;
            margin-top: -5px;
        }

        .p2-info .stats-row-composite {
            flex-direction: row-reverse;
        }

        .big-stat {
            display: flex;
            align-items: baseline;
            gap: 5px;
        }

        .stat-label {
            font-size: 14px;
            color: #666;
            font-weight: bold;
        }

        .stat-val {
            font-size: 48px;
            font-weight: 900;
            line-height: 1;
        }

        .skill-val {
            font-size: 32px;
            color: #f1c40f;
            text-shadow: 0 0 10px rgba(241, 196, 15, 0.2);
        }

        .bar-bg {
            width: 100%;
            height: 8px;
            background: #333;
            margin-top: 5px;
            border-radius: 4px;
            overflow: hidden;
            position: relative;
        }

        .xp-bar {
            height: 100%;
            transition: width 0.2s;
        }

        .player-msg {
            height: 20px;
            margin-top: 4px;
            font-size: 14px;
            font-weight: bold;
            text-transform: uppercase;
            letter-spacing: 1px;
            opacity: 0;
            transition: opacity 0.3s;
        }

        .status-badge {
            padding: 1px 4px;
            border-radius: 2px;
            font-size: 10px;
            font-weight: bold;
            box-shadow: 0 0 5px currentColor;
            display: inline-block;
            margin: 0 2px;
        }

        .blind-badge {
            background: #fff;
            color: #000;
            animation: flash 0.5s infinite;
        }

        .boost-badge {
            background: #0055ff;
            color: #fff;
            border: 1px solid #00ffff;
            box-shadow: 0 0 10px #0055ff;
            animation: pulse-blue 1s infinite;
        }

        .wait-badge {
            background: #e67e22;
            color: #fff;
            border: 1px solid #d35400;
            box-shadow: 0 0 10px #e67e22;
        }

        @keyframes flash {
            0% { opacity: 1; }
            50% { opacity: 0.5; }
            100% { opacity: 1; }
        }

        @keyframes pulse-blue {
            0% { box-shadow: 0 0 5px #0055ff; }
            50% { box-shadow: 0 0 15px #00ffff; }
            100% { box-shadow: 0 0 5px #0055ff; }
        }

        /* --- GAME AREA --- */
        #game-area {
            flex-grow: 1;
            position: relative;
            background: #000;
            width: 100%;
            overflow: hidden;
            display: flex;
            justify-content: center;
            align-items: center;
            padding: 20px;
            box-sizing: border-box;
        }

        canvas {
            display: block;
            background-color: #111;
            border: 3px solid #444;
            box-shadow: 0 0 50px rgba(0, 0, 0, 0.8);
        }

        /* --- OVERLAY SCREENS --- */
        #overlay-screen {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(5, 5, 5, 0.98);
            display: flex;
            flex-direction: column;
            justify-content: flex-start;
            align-items: center;
            z-index: 100;
            transition: opacity 0.3s;
            overflow-y: auto;
            padding-top: 10px;
        }

        #start-content,
        #end-content {
            display: flex;
            flex-direction: column;
            align-items: center;
            width: 100%;
            padding: 20px 0;
        }

        h1 {
            font-family: 'Roboto', sans-serif;
            font-size: 64px;
            background: linear-gradient(to right, #2ecc71, #f1c40f);
            -webkit-background-clip: text;
            color: transparent;
            margin-bottom: 20px;
            letter-spacing: 5px;
            text-transform: uppercase;
            text-align: center;
            text-indent: 5px;
        }

        #capture-target {
            display: flex;
            flex-direction: column;
            align-items: center;
            width: 96%; /* FULL WIDTH UPDATE */
            max-width: none; /* REMOVE LIMIT */
            background: #0b0b0b;
            padding: 30px;
            border-radius: 10px;
            margin-bottom: 20px;
            box-sizing: border-box;
        }

        .content-box {
            background: rgba(255, 255, 255, 0.05);
            padding: 30px 40px;
            border-radius: 12px;
            border: 1px solid #333;
            width: 100%;
            text-align: left;
            box-sizing: border-box;
        }

        #start-content .content-box {
            max-width: 950px;
            margin-bottom: 20px;
        }

        .rule-title {
            color: #f1c40f;
            font-weight: bold;
            font-size: 20px;
            margin-bottom: 10px;
            font-family: 'sans-serif';
            border-bottom: 1px solid #444;
            padding-bottom: 5px;
        }

        .rule-row {
            display: flex;
            margin-bottom: 10px;
            align-items: center;
        }

        .icon {
            width: 40px;
            font-size: 24px;
            text-align: center;
            margin-right: 15px;
        }

        .desc {
            color: #ccc;
            font-size: 16px;
            line-height: 1.4;
        }

        /* --- MAP SELECTION --- */
        .map-select-row {
            display: flex;
            justify-content: center;
            gap: 40px;
            margin: 20px 0;
            padding: 15px;
            background: rgba(255,255,255,0.05);
            border-radius: 8px;
            border: 1px solid #444;
        }
        .map-option {
            display: flex;
            align-items: center;
            gap: 10px;
            cursor: pointer;
            font-size: 18px;
            color: #ddd;
        }
        .map-option input {
            transform: scale(1.5);
            accent-color: #2ecc71;
            cursor: pointer;
        }

        /* --- RESULTS --- */
        .result-header {
            text-align: center;
            margin-bottom: 20px;
            width: 100%;
        }

        .winner-announce {
            font-size: 72px; /* INCREASED */
            font-weight: 900;
            font-family: 'sans-serif';
            margin-bottom: 10px;
            text-shadow: 0 0 25px currentColor;
        }

        .reason-text {
            color: #aaa;
            font-size: 28px; /* INCREASED */
            margin-bottom: 20px;
            font-style: italic;
        }

        .stat-grid {
            display: flex;
            flex-direction: column;
            width: 100%;
            gap: 0;
        }

        .stat-row {
            display: grid;
            grid-template-columns: 1fr 200px 1fr;
            align-items: center;
            border-bottom: 1px solid rgba(255, 255, 255, 0.1);
            padding: 10px 0; /* INCREASED PADDING */
            transition: background 0.2s;
        }

        .stat-row:hover {
            background: rgba(255, 255, 255, 0.02);
        }

        .stat-label {
            color: #888;
            text-align: center;
            font-size: 20px; /* INCREASED */
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 10px;
            white-space: nowrap;
        }

        .p1-val, .p2-val {
            font-family: 'sans-serif';
            font-weight: bold;
            text-align: center;
            font-size: 24px; /* INCREASED */
        }

        .level-row {
            padding: 15px 0;
            border-bottom: 2px solid #444;
            margin-bottom: 15px;
        }
        .level-row .p1-val, .level-row .p2-val {
            font-size: 5rem; /* INCREASED */
            text-shadow: 0 0 20px currentColor;
        }
        .level-row .stat-label {
            font-size: 2rem; /* INCREASED */
            color: #fff;
            font-weight: bold;
        }

        .total-row {
            border-top: 2px solid #555;
            border-bottom: none;
            margin-top: 20px;
            padding-top: 20px;
        }
        .total-row .stat-label, .total-row .p1-val, .total-row .p2-val {
            font-size: 24px; /* INCREASED */
            color: #fff;
        }

        .item-dot {
            width: 14px; height: 14px; display: inline-block; border-radius: 50%;
        }

        .btn-container { text-align: center; margin-top: 10px; }
        .btn {
            margin: 10px;
            padding: 15px 40px;
            font-size: 20px;
            font-family: 'Roboto', sans-serif;
            background: transparent;
            color: #2ecc71;
            border: 2px solid #2ecc71;
            cursor: pointer;
            transition: 0.2s;
            border-radius: 5px;
        }
        .btn:hover { background: #2ecc71; color: #000; box-shadow: 0 0 20px #2ecc71; }
        .btn-blue { color: #3498db; border-color: #3498db; }
        .btn-blue:hover { background: #3498db; color: #fff; box-shadow: 0 0 20px #3498db; }
        .btn-red-sm {
            padding: 6px 12px;
            font-size: 14px;
            color: #e74c3c;
            border: 1px solid #e74c3c;
            background: transparent;
            cursor: pointer;
            border-radius: 4px;
            margin-left: 15px;
            vertical-align: middle;
        }
        .btn-red-sm:hover { background: #e74c3c; color: white; }

        .hidden { display: none !important; }

        /* --- CHART & ANALYSIS --- */
        #chart-container {
            width: 100%;
            height: 400px;
            margin-top: 30px;
            background: rgba(0, 0, 0, 0.3);
            border: 1px solid #333;
            border-radius: 8px;
            padding: 15px;
            box-sizing: border-box;
        }
        #chartCanvas { width: 100%; height: 100%; }

        /* Segment Table Styles */
        #segment-analysis, #leaderboard-section {
            width: 100%;
            margin-top: 40px;
        }
        
        .section-title {
            color: #f1c40f;
            font-size: 24px; /* INCREASED */
            font-weight: bold;
            margin-bottom: 15px;
            border-left: 6px solid #f1c40f;
            padding-left: 15px;
            display: flex;
            align-items: center;
        }

        .analysis-table, .lb-table {
            width: 100%;
            border-collapse: collapse;
            font-size: 18px; /* INCREASED */
            text-align: center;
        }
        .analysis-table th, .analysis-table td,
        .lb-table th, .lb-table td {
            border: 1px solid #333;
            padding: 12px 8px; /* INCREASED */
            color: #ccc;
        }
        .analysis-table th, .lb-table th {
            background: rgba(255,255,255,0.05);
            color: #fff;
            font-weight: bold;
            font-size: 20px; /* INCREASED */
        }
        .win-seg { color: #2ecc71; font-weight: bold; }
        .lose-seg { color: #e74c3c; }

        /* Leaderboard Specifics */
        .lb-container {
            display: flex;
            gap: 20px;
            margin-top: 15px;
        }
        .lb-box {
            flex: 1;
            background: rgba(0,0,0,0.4);
            padding: 15px;
            border-radius: 8px;
            border: 1px solid #333;
            overflow-x: auto;
            min-width: 0;
        }
        .lb-header {
            text-align: center;
            font-weight: bold;
            color: #ccc;
            margin-bottom: 12px;
            text-transform: uppercase;
            font-size: 18px; /* INCREASED */
            border-bottom: 1px solid #444;
            padding-bottom: 8px;
        }
        
        .lb-header.pvp { color: #2ecc71; }
        .lb-header.pve { color: #f39c12; }
        .lb-header.aivai { color: #e74c3c; }
        
        .lb-table { font-size: 14px; } /* Slightly larger than before */
        .lb-table th, .lb-table td { padding: 6px 4px; }
        
        .lb-rank { width: 30px; color: #888; font-size: 16px; }
        .lb-name { text-align: left; max-width: 80px; overflow: hidden; text-overflow: ellipsis; white-space: nowrap; font-weight: bold; font-size: 15px;}
        .lb-total { color: #f1c40f; font-weight: bold; width: 50px; font-size: 16px; }
        .lb-seg { font-size: 13px; color: #999; width: 35px; }
        
        ::-webkit-scrollbar { width: 8px; height: 8px; }
        ::-webkit-scrollbar-track { background: #000; }
        ::-webkit-scrollbar-thumb { background: #333; border-radius: 4px; }
        ::-webkit-scrollbar-thumb:hover { background: #555; }
    </style>
</head>

<body>

    <div id="ui-bar">
        <div class="player-info p1-info" id="p1-panel">
            <div class="input-group">
                <input type="text" id="p1-name-in" value="PLAYER 1" class="name-input" maxlength="12">
                <input type="color" id="p1-color-in" value="#3498db" class="color-picker">
                <label class="ai-label" id="p1-ai-label">
                    <input type="checkbox" id="p1-ai-toggle" class="ai-checkbox"> AI
                </label>
                <span id="p1-blind-tag" class="status-badge blind-badge hidden">BLINDED</span>
                <span id="p1-boost-tag" class="status-badge boost-badge hidden">XP BOOST</span>
                <span id="p1-wait-tag" class="status-badge wait-badge hidden">WAITING</span>
            </div>

            <div class="stats-row-composite">
                <div class="big-stat">
                    <span class="stat-label">LV</span>
                    <span id="p1-lv" class="stat-val">1</span>
                </div>
                <div class="big-stat">
                    <span class="stat-label">[Q]</span>
                    <span id="p1-charges" class="stat-val skill-val">0</span>
                </div>
            </div>

            <div class="bar-bg">
                <div id="p1-bar" class="xp-bar" style="width:0%"></div>
            </div>
            <div id="p1-msg" class="player-msg"></div>
        </div>

        <div class="center-display">
            <div id="timer-display">90</div>
            <div class="timer-label">SECONDS LEFT</div>
        </div>

        <div class="player-info p2-info" id="p2-panel">
            <div class="input-group">
                <input type="text" id="p2-name-in" value="PLAYER 2" class="name-input" maxlength="12">
                <input type="color" id="p2-color-in" value="#e74c3c" class="color-picker">
                <label class="ai-label" id="p2-ai-label">
                    <input type="checkbox" id="p2-ai-toggle" class="ai-checkbox"> AI
                </label>
                <span id="p2-blind-tag" class="status-badge blind-badge hidden">BLINDED</span>
                <span id="p2-boost-tag" class="status-badge boost-badge hidden">XP BOOST</span>
                <span id="p2-wait-tag" class="status-badge wait-badge hidden">WAITING</span>
            </div>

            <div class="stats-row-composite">
                <div class="big-stat">
                    <span class="stat-label">LV</span>
                    <span id="p2-lv" class="stat-val">1</span>
                </div>
                <div class="big-stat">
                    <span class="stat-label">[ENTER]</span>
                    <span id="p2-charges" class="stat-val skill-val">0</span>
                </div>
            </div>

            <div class="bar-bg">
                <div id="p2-bar" class="xp-bar" style="width:0%"></div>
            </div>
            <div id="p2-msg" class="player-msg"></div>
        </div>
    </div>

    <div id="game-area">
        <canvas id="gameCanvas"></canvas>

        <div id="overlay-screen">
            <div id="start-content">
                <h1>Shadow Racing</h1>
                
                <div class="map-select-row">
                    <label class="map-option">
                        <input type="radio" name="map_mode" value="fixed" checked>
                        Âõ∫ÂÆöÂú∞Âúñ (30x12) <span style="font-size:12px; color:#888;">(ÊéíË°åÊ¶úÊúâÊïà)</span>
                    </label>
                    <label class="map-option">
                        <input type="radio" name="map_mode" value="fill">
                        ÊúÄÂ§ßÂåñ (Â°´ÊªøÁï´Èù¢)
                    </label>
                </div>

                <div class="content-box">
                    <div class="rule-title">ÈÅìÂÖ∑ËàáË¶èÂâá</div>
                    <div class="rule-row"><span class="icon">üî¢</span><span
                            class="desc">ÂêÉÊéâÊï∏Â≠óÂ¢ûÂä†Á∂ìÈ©ó„ÄÇ<strong>ÊØèÂçá‰∏ÄÁ¥öÔºåË¶ñÈáéÂ¢ûÂä†ÔºåÁßªÂãïÈÄüÂ∫¶ÊèêÂçáÔºåÈï∑Â∫¶Â¢ûÂä†ÔºÅ</strong></span></div>
                    <div class="rule-row"><span class="icon" style="color:red; font-weight:bold">Q</span><span
                            class="desc">Áç≤ÂæóËá¥Áõ≤ÊäÄËÉΩ (Â∞çÊâãË¶ñÈáéÂâ© 40% / 3Áßí)„ÄÇ<strong>AI Áç≤ÂæóÂæåÊúÉËá™ÂãïÊñΩÊîæ„ÄÇ</strong></span></div>
                    <div class="rule-row"><span class="icon"
                            style="color:#00ffff; font-weight:bold; text-shadow:0 0 5px #0055ff">E</span><span
                            class="desc"><strong>XP BOOSTÔºö</strong> Áç≤ÂæóÈ°çÂ§ñ 50% Á∂ìÈ©óÂÄº (ÊåÅÁ∫å 5 Áßí)Ôºå<strong>‰∏¶ÁôºÂá∫Ëá™Ë∫´È°èËâ≤ÁöÑÂÖâËäí</strong>„ÄÇAI
                            Â∞áÂÑ™ÂÖàÁà≠Â•™Ê≠§ÈÅìÂÖ∑ÔºÅ</span></div>
                    <div class="rule-row"><span class="icon" style="font-size:20px">üîÑ</span><span
                            class="desc"><strong>Ê∑∑‰∫ÇÂ∞çÊâãÔºö</strong> ËÆìÂ∞çÊâã<strong>Âº∑Âà∂ 90 Â∫¶ËΩâÂêë</strong> (Èö®Ê©ü)„ÄÇ</span></div>

                    <div class="rule-title" style="margin-top:15px">Êìç‰ΩúËàá AI ËÆìË≥Ω</div>
                    <div class="rule-row"><span class="icon" style="color:#3498db">P1</span><span class="desc"><strong>W
                                A S D</strong> ÁßªÂãï„ÄÇ <strong>Q Èçµ</strong>ÔºöËá¥Áõ≤„ÄÇ<br>(Ëã•ÈñãÂïüAIÔºåÂâáËá™ÂãïÊìç‰Ωú)</span></div>
                    <div class="rule-row"><span class="icon" style="color:#e74c3c">P2</span><span
                            class="desc"><strong>ÊñπÂêëÈçµ</strong> ÁßªÂãï„ÄÇ <strong>Enter Èçµ</strong>ÔºöËá¥Áõ≤„ÄÇ<br>(Ëã•ÈñãÂïüAIÔºåÂâáËá™ÂãïÊìç‰Ωú)</span>
                    </div>
                    <div class="rule-row"><span class="icon">ü§ñ</span><span class="desc"
                            style="color:#e67e22"><strong>‰∫∫Ê©üÂ∞çÊà∞Ë¶èÂâáÔºö</strong> Ëã•‰∏ÄÊñπÁÇ∫‰∫∫È°ûÔºå‰∏ÄÊñπÁÇ∫ AIÔºå<strong>AI Â∞áÊúÉËÆìË≥Ω 45
                                ÁßíÔºàÂéüÂú∞ÈùúÊ≠¢Ôºâ</strong>„ÄÇ</span></div>
                </div>
                <div style="text-align:center"><button class="btn" onclick="startGame()">START GAME (Enter)</button>
                </div>
            </div>

            <div id="end-content" class="hidden">
                <div id="capture-target">
                    <div class="result-header">
                        <div id="winner-title" class="winner-announce">PLAYER 1 WINS!</div>
                        <div id="win-reason" class="reason-text">Higher Level</div>
                        <div id="map-size-info" style="color:#666; font-size:14px; margin-top:5px;">MAP: 0x0</div>
                    </div>

                    <div class="content-box">
                        <div class="stat-grid" id="stat-table">
                            </div>

                        <div id="chart-container">
                            <canvas id="chartCanvas"></canvas>
                        </div>

                        <div id="segment-analysis">
                            <div class="section-title">ÈöéÊÆµÁ∂ìÈ©óÁç≤ÂèñÂàÜÊûê (XP per 15s)</div>
                            <table class="analysis-table" id="seg-table-body">
                                </table>
                        </div>

                        <div id="leaderboard-section" class="hidden">
                            <div class="section-title">
                                30x12 Ê®°ÂºèÊéíË°åÊ¶ú (TOP 10) 
                                <button onclick="clearLeaderboard()" class="btn-red-sm">üóëÔ∏è Ê∏ÖÈô§Ë®òÈåÑ</button>
                            </div>
                            <div class="lb-container">
                                <div class="lb-box">
                                    <div class="lb-header pvp">‚öîÔ∏è PvP (‰∫∫‰∫∫)</div>
                                    <table class="lb-table">
                                        <thead>
                                            <tr>
                                                <th class="lb-rank">#</th>
                                                <th class="lb-name">Name</th>
                                                <th>Total</th>
                                                <th title="0-15s">S1</th><th title="15-30s">S2</th><th title="30-45s">S3</th>
                                                <th title="45-60s">S4</th><th title="60-75s">S5</th><th title="75-90s">S6</th>
                                            </tr>
                                        </thead>
                                        <tbody id="lb-pvp-body"></tbody>
                                    </table>
                                </div>
                                <div class="lb-box">
                                    <div class="lb-header pve">ü§ñ PvE (‰∫∫Ê©ü)</div>
                                    <table class="lb-table">
                                        <thead>
                                            <tr>
                                                <th class="lb-rank">#</th>
                                                <th class="lb-name">Name</th>
                                                <th>Total</th>
                                                <th title="0-15s">S1</th><th title="15-30s">S2</th><th title="30-45s">S3</th>
                                                <th title="45-60s">S4</th><th title="60-75s">S5</th><th title="75-90s">S6</th>
                                            </tr>
                                        </thead>
                                        <tbody id="lb-pve-body"></tbody>
                                    </table>
                                </div>
                                <div class="lb-box">
                                    <div class="lb-header aivai">üíª AIvAI (Ê©üÊ©ü)</div>
                                    <table class="lb-table">
                                        <thead>
                                            <tr>
                                                <th class="lb-rank">#</th>
                                                <th class="lb-name">Name</th>
                                                <th>Total</th>
                                                <th title="0-15s">S1</th><th title="15-30s">S2</th><th title="30-45s">S3</th>
                                                <th title="45-60s">S4</th><th title="60-75s">S5</th><th title="75-90s">S6</th>
                                            </tr>
                                        </thead>
                                        <tbody id="lb-aivai-body"></tbody>
                                    </table>
                                </div>
                            </div>
                        </div>
                    </div>
                </div>

                <div class="btn-container">
                    <button class="btn btn-blue" onclick="captureScreenshot()">üì∑ Screenshot to Clipboard</button>
                    <button class="btn" onclick="location.reload()">RESTART (R)</button>
                </div>
            </div>
        </div>
    </div>

    <script>
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');
        const shadowCanvas = document.createElement('canvas');
        const shadowCtx = shadowCanvas.getContext('2d');

        // --- ÈÖçÁΩÆ ---
        const CELL_SIZE_BASE = 30; // Âü∫Êú¨Â§ßÂ∞è
        let CELL_SIZE = 30;
        let GRID_W, GRID_H;
        let MAP_MODE = 'fixed'; // 'fixed' | 'fill'

        const SPEED_BASE_THRESHOLD = 80;
        const SPEED_INCREASE_FACTOR = 1.05;

        const GAME_DURATION = 90;
        const BLIND_DURATION = 3.0;
        const VISION_BASE_DIST = 5.5;
        const VISION_BASE_ANGLE = 80;
        const VISION_PER_LV_DIST = 0.6;
        const VISION_PER_LV_ANGLE = 8;
        const BLIND_FACTOR = 0.4;
        const AI_HANDICAP_SECONDS = 45;

        let P1_COLOR = '#3498db';
        let P2_COLOR = '#e74c3c';

        const ITEM_COLORS = {
            xp5: '#95a5a6', xp15: '#2ecc71', xp20: '#3498db', xp30: '#9b59b6', xp99: '#f1c40f',
            skillQ: '#ff0000', buffE: '#00ffff', chaos: '#d35400'
        };

        const COMMON_COLORS = { bg: '#111', grid: '#1a1a1a', shadow: '#000000' };

        let gameLoopId;
        let lastTime = 0;
        let timeLeft = GAME_DURATION;
        let isGameOver = false;
        let snakes = [];
        let items = [];
        let pendingSpawns = [];

        // Ë®òÈåÑÊï∏ÊìöÁî®ÊñºÂúñË°®
        let xpHistory = {
            times: [],
            p1: [],
            p2: []
        };
        let historyTimer = 0;

        const ITEM_CONFIG = [
            { id: 'xp5', val: 5, count: 60, color: ITEM_COLORS.xp5, type: 'xp', delay: 0 },
            { id: 'xp15', val: 15, count: 20, color: ITEM_COLORS.xp15, type: 'xp', delay: 0 },
            { id: 'xp20', val: 20, count: 10, color: ITEM_COLORS.xp20, type: 'xp', delay: 0 },
            { id: 'xp30', val: 30, count: 5, color: ITEM_COLORS.xp30, type: 'xp', delay: 0 },
            { id: 'xp99', val: 99, count: 1, color: ITEM_COLORS.xp99, type: 'xp', delay: 0 },
            { id: 'skill', val: 0, count: 1, color: ITEM_COLORS.skillQ, type: 'skill', delay: 0 },
            { id: 'buffE', val: 0, count: 1, color: ITEM_COLORS.buffE, type: 'buffE', delay: 0 },
            { id: 'chaos', val: 0, count: 1, color: ITEM_COLORS.chaos, type: 'chaos', delay: 0 }
        ];

        const p1NameIn = document.getElementById('p1-name-in');
        const p2NameIn = document.getElementById('p2-name-in');
        const p1ColorIn = document.getElementById('p1-color-in');
        const p2ColorIn = document.getElementById('p2-color-in');
        const p1AiToggle = document.getElementById('p1-ai-toggle');
        const p2AiToggle = document.getElementById('p2-ai-toggle');

        // --- ËºâÂÖ•Ë®≠ÂÆö ---
        function loadSettings() {
            const savedP1Ai = localStorage.getItem('sr_p1_ai');
            const savedP2Ai = localStorage.getItem('sr_p2_ai');
            if (savedP1Ai !== null) p1AiToggle.checked = (savedP1Ai === 'true');
            if (savedP2Ai !== null) p2AiToggle.checked = (savedP2Ai === 'true');
        }
        loadSettings();

        function updatePanelStyles() {
            P1_COLOR = p1ColorIn.value;
            P2_COLOR = p2ColorIn.value;

            document.querySelector('.p1-info').style.borderColor = P1_COLOR;
            document.querySelector('.p1-info').style.color = P1_COLOR;
            document.getElementById('p1-msg').style.color = P1_COLOR;

            document.querySelector('.p2-info').style.borderColor = P2_COLOR;
            document.querySelector('.p2-info').style.color = P2_COLOR;
            document.getElementById('p2-msg').style.color = P2_COLOR;

            document.getElementById('p1-bar').style.backgroundColor = P1_COLOR;
            document.getElementById('p2-bar').style.backgroundColor = P2_COLOR;
        }

        p1ColorIn.addEventListener('input', updatePanelStyles);
        p2ColorIn.addEventListener('input', updatePanelStyles);
        updatePanelStyles();

        function hexToRgba(hex, alpha) {
            hex = hex.replace('#', '');
            if (hex.length === 3) hex = hex[0]+hex[0]+hex[1]+hex[1]+hex[2]+hex[2];
            let r = parseInt(hex.substring(0, 2), 16);
            let g = parseInt(hex.substring(2, 4), 16);
            let b = parseInt(hex.substring(4, 6), 16);
            return `rgba(${r}, ${g}, ${b}, ${alpha})`;
        }

        class Snake {
            constructor(id, name, x, y, dirX, dirY, color, isAI) {
                this.id = id; this.name = name; this.color = color; this.isAI = isAI;
                this.body = [{ x, y }];
                this.dir = { x: dirX, y: dirY };
                this.nextDir = { x: dirX, y: dirY };
                this.xp = 0; this.maxXp = 100; this.level = 1; this.totalAccumulatedXp = 0;
                this.moveAcc = 0; this.currentSpeedThreshold = SPEED_BASE_THRESHOLD;
                this.skillCharges = 0; this.blindTimer = 0; this.deadTimer = 0;
                this.xpBoostTimer = 0; this.xpMultiplier = 1.0;
                this.startDelay = 0;
                this.stats = { totalDist: 0, items: { xp5: 0, xp15: 0, xp20: 0, xp30: 0, xp99: 0, skill: 0, buffE: 0, chaos: 0 } };
            }
            respawn() {
                this.deadTimer = 2.0; this.body = [{ x: -999, y: -999 }];
                this.xpBoostTimer = 0; this.xpMultiplier = 1.0;
                showMsg(this.id, "CRASHED!");
            }
            resetToMap() {
                let centerY = Math.floor(GRID_H / 2);
                if (this.id === 1) { this.body = [{ x: 3, y: centerY }]; this.dir = { x: 1, y: 0 }; this.nextDir = { x: 1, y: 0 }; } 
                else { this.body = [{ x: GRID_W - 4, y: centerY }]; this.dir = { x: -1, y: 0 }; this.nextDir = { x: -1, y: 0 }; }
            }
            applyBlind() { this.blindTimer = BLIND_DURATION; }
            forceTurn() {
                let newX = 0, newY = 0;
                let randomSign = Math.random() < 0.5 ? 1 : -1;
                if (this.dir.x !== 0) { newX = 0; newY = randomSign; } else { newX = randomSign; newY = 0; }
                this.nextDir = { x: newX, y: newY }; this.dir = { x: newX, y: newY };
            }
          thinkAI() {
                // 0. ÊúâÊäÄËÉΩÂ∞±Êîæ (‰øÆÂæ©‰πãÂâçÁöÑË¢´ÂãïÂïèÈ°å)
                this.tryAutoCastSkill();

                const head = this.body[0];
                let radiusGrid = VISION_BASE_DIST + (this.level - 1) * VISION_PER_LV_DIST;
                if (this.blindTimer > 0) radiusGrid *= BLIND_FACTOR;

                // 1. ÊâæÂá∫ÊâÄÊúâ„ÄåÂü∫Á§éÂÆâÂÖ®„ÄçÁöÑÁßªÂãïÊñπÂêë (‰∏çÊíûÁâÜ„ÄÅ‰∏çÊíûËõá)
                const moves = [{ x: 0, y: -1 }, { x: 0, y: 1 }, { x: -1, y: 0 }, { x: 1, y: 0 }];
                let validMoves = moves.filter(m => {
                    // Á¶ÅÊ≠¢ÂõûÈ†≠
                    if (m.x === -this.dir.x && m.y === -this.dir.y) return false;
                    
                    const nx = head.x + m.x; 
                    const ny = head.y + m.y;
                    
                    // ÊíûÁâÜÊ™¢Êü•
                    if (nx < 0 || nx >= GRID_W || ny < 0 || ny >= GRID_H) return false;
                    
                    // ÊíûËõáÊ™¢Êü• (Ê™¢Êü•ÊâÄÊúâËõáÁöÑË∫´È´î)
                    // Ê≥®ÊÑèÔºöÈÄôË£°Á∞°ÂñÆÂà§Êñ∑ÔºåÂ¶ÇÊûúÈ†êÊ∏¨Âà∞Â∞çÊâã‰∏ãÂÄãÈ†≠ÁöÑ‰ΩçÁΩÆÂèØËÉΩÊúÉÊíûÔºåÊúÄÂ•Ω‰πüÈÅøÈñãÔºåÈÄôË£°ÂÖàÂè™ÈÅøÈñãË∫´È´î
                    let collision = snakes.some(s => s.body.some(b => b.x === nx && b.y === ny));
                    if (collision) return false;

                    return true;
                });

                // Â¶ÇÊûúÁÑ°Ë∑ØÂèØËµ∞ÔºåÂ∞±Èö®‰æøÈÅ∏‰∏ÄÂÄãÊ≠ªÊéâ (ÈÅøÂÖçÂ†±ÈåØ)
                if (validMoves.length === 0) return;

                // 2.„ÄêÊ†∏ÂøÉÈÄ≤Âåñ„ÄëÈÅéÊøæÂá∫„ÄåÊúâÂæåË∑Ø„ÄçÁöÑÁßªÂãïÊñπÂêë
                // Âè™ÊúâÁï∂ÁßªÂãïÂæåÁöÑ‰ΩçÁΩÆÔºåÂèØ‰ª•ÈÄöÈÅé BFS ÊâæÂà∞Âú∞ÂúñÈÇäÁïåÔºåÊâçÁÆóÊòØ„ÄåÁúü¬∑ÂÆâÂÖ®„Äç
                let safeEscapeMoves = validMoves.filter(m => {
                    return checkEscapeRoute(head.x + m.x, head.y + m.y, this.id);
                });

                // Â¶ÇÊûúÁ∂ìÈÅéÈÅéÊøæÈÇÑÊúâË∑ØÔºåÂ∞±Âè™ËÄÉÊÖÆÈÄô‰∫õÊúâÂæåË∑ØÁöÑÊñπÂêëÔºõ
                // Â¶ÇÊûúÈÅéÊøæÂÆåÁôºÁèæÂÖ®ÊòØÊ≠ªË∑Ø (Ë¢´ÂÆåÂÖ®ÂåÖÂúç)ÔºåÈÇ£Âè™ËÉΩÂæûÂü∫Á§éÂÆâÂÖ®Ê≠•Ë£°ÈÅ∏(Áõ°ÈáèÊãñÊôÇÈñì)
                let candidateMoves = safeEscapeMoves.length > 0 ? safeEscapeMoves : validMoves;

                // 3. Â∞ãÊâæË¶ñÈáéÂÖßÁöÑÈÅìÂÖ∑
                let visibleItems = items.filter(it => {
                    let dx = it.x - head.x; let dy = it.y - head.y;
                    return Math.sqrt(dx * dx + dy * dy) <= radiusGrid;
                });

                let bestMove = null;
                let maxScore = -99999;

                // Â¶ÇÊûúË¶ñÈáéÂÖßÊúâÈÅìÂÖ∑ÔºåË©ï‰º∞Âì™ÂÄãÊñπÂêëÊúÄÂ•Ω
                if (visibleItems.length > 0) {
                    // ÁÇ∫ÊØèÂÄãÂÄôÈÅ∏ÁßªÂãïÊâìÂàÜ
                    candidateMoves.forEach(move => {
                        let nx = head.x + move.x;
                        let ny = head.y + move.y;
                        let score = 0;

                        // Âà§Êñ∑Ê≠§ÁßªÂãïÊòØÂê¶Áõ¥Êé•ÂêÉÂà∞Êù±Ë•ø
                        let directItem = visibleItems.find(it => it.x === nx && it.y === ny);
                        if (directItem) {
                            if (directItem.def.type === 'buffE') score += 5000; // E ÈÅìÂÖ∑ÂÑ™ÂÖàÁ¥öÊúÄÈ´ò
                            else if (directItem.def.type === 'xp99') score += 1000;
                            else if (directItem.def.type === 'xp') score += directItem.def.val;
                            else score += 50;
                        } else {
                            // Ê≤íÁõ¥Êé•ÂêÉÂà∞Ôºå‰ΩÜÈù†Ëøë‰∫ÜÈ´òÂÉπÂÄºÁõÆÊ®ôÂóéÔºü
                            // ÊâæË¶ñÈáéÂÖßÂÉπÂÄºÊúÄÈ´òÁöÑÊù±Ë•ø
                            let target = visibleItems.reduce((prev, curr) => {
                                let wPrev = (prev.def.type === 'buffE' ? 1000 : prev.def.val);
                                let wCurr = (curr.def.type === 'buffE' ? 1000 : curr.def.val);
                                return wCurr > wPrev ? curr : prev;
                            });
                            
                            // Ë®àÁÆóÁßªÂãïÂæåË∑ùÈõ¢ÁõÆÊ®ôÁöÑË∑ùÈõ¢
                            let distAfterMove = Math.abs(nx - target.x) + Math.abs(ny - target.y);
                            let currentDist = Math.abs(head.x - target.x) + Math.abs(head.y - target.y);
                            
                            // Â¶ÇÊûúÈù†Ëøë‰∫ÜÁõÆÊ®ôÔºåÂä†ÂàÜ
                            if (distAfterMove < currentDist) {
                                score += (target.def.type === 'buffE' ? 200 : 20);
                            }
                        }

                        if (score > maxScore) {
                            maxScore = score;
                            bestMove = move;
                        }
                    });
                }

                // 4. Ê±∫Á≠ñÂü∑Ë°å
                if (bestMove) {
                    this.nextDir = bestMove;
                } else {
                    // Ë¶ñÈáéÂÖßÊ≤íÊù±Ë•øÔºåÊàñËÄÖÂàÜÊï∏ÈÉΩ‰∏ÄÊ®£
                    // ÂÑ™ÂÖàÁπºÁ∫åÁõ¥Ëµ∞ (ÁúãËµ∑‰æÜÊØîËºÉËá™ÁÑ∂)ÔºåÈô§ÈùûÁõ¥Ëµ∞‰∏çÂÆâÂÖ®ÊàñÊ≤íÂæåË∑Ø
                    let forwardMove = candidateMoves.find(m => m.x === this.dir.x && m.y === this.dir.y);
                    if (forwardMove) {
                        // Á®çÂæÆÂä†‰∏ÄÈªûÈö®Ê©üËΩâÂêëÔºåÈÅøÂÖçÂÆÉ‰∏ÄÁõ¥Áõ¥Ëµ∞ÊíûÁâÜ
                        if (Math.random() > 0.1) this.nextDir = forwardMove;
                        else this.nextDir = candidateMoves[Math.floor(Math.random() * candidateMoves.length)];
                    } else {
                        // ‰∏çËÉΩÁõ¥Ëµ∞ÔºåÈö®Ê©üÈÅ∏‰∏ÄÂÄãÂÆâÂÖ®ÁöÑ
                        this.nextDir = candidateMoves[Math.floor(Math.random() * candidateMoves.length)];
                    }
                }
            }
            tryAutoCastSkill() {
                const opponent = snakes.find(s => s.id !== this.id);
                if (opponent && opponent.deadTimer <= 0) this.useSkill(opponent);
            }
            update(dt) {
                if (this.deadTimer > 0) {
                    this.deadTimer -= dt;
                    if (this.deadTimer <= 0) this.resetToMap();
                    return;
                }
                if (this.startDelay > 0) {
                    this.startDelay -= dt;
                    if (this.startDelay <= 0) { this.startDelay = 0; showMsg(this.id, "AI STARTED!"); }
                    else return;
                }
                if (this.blindTimer > 0) this.blindTimer -= dt;
                if (this.xpBoostTimer > 0) {
                    this.xpBoostTimer -= dt;
                    if (this.xpBoostTimer <= 0) { this.xpBoostTimer = 0; this.xpMultiplier = 1.0; showMsg(this.id, "BOOST END"); }
                }
                this.moveAcc += dt * 1000;
                if (this.moveAcc >= this.currentSpeedThreshold) {
                    if (this.isAI) this.thinkAI();
                    this.moveAcc = 0; this.move();
                }
            }
            move() {
                if (this.nextDir.x !== -this.dir.x && this.nextDir.y !== -this.dir.y) this.dir = this.nextDir;
                let head = this.body[0];
                let nx = head.x + this.dir.x;
                let ny = head.y + this.dir.y;
                if (nx < 0 || nx >= GRID_W || ny < 0 || ny >= GRID_H) { this.respawn(); return; }
                if (this.body.some(b => b.x === nx && b.y === ny)) { this.respawn(); return; }
                let newHead = { x: nx, y: ny };
                this.stats.totalDist++;
                let itemIdx = items.findIndex(i => i.x === nx && i.y === ny);
                if (itemIdx !== -1) {
                    let it = items[itemIdx];
                    let cfg = it.def;
                    if (this.stats.items[cfg.id] !== undefined) this.stats.items[cfg.id]++;
                    if (cfg.type === 'xp') this.gainXP(cfg.val);
                    else if (cfg.type === 'skill') {
                        this.skillCharges++; showMsg(this.id, "GOT SKILL!");
                        if (this.isAI) this.tryAutoCastSkill();
                    } else if (cfg.type === 'buffE') {
                        this.xpBoostTimer = 5.0; this.xpMultiplier = 1.5; showMsg(this.id, "XP x1.5!");
                    } else if (cfg.type === 'chaos') {
                        let opponent = snakes.find(s => s.id !== this.id);
                        if (opponent && opponent.deadTimer <= 0) {
                            opponent.forceTurn(); showMsg(this.id, "CHAOS!"); showMsg(opponent.id, "SPUN!");
                        }
                    }
                    items.splice(itemIdx, 1);
                    scheduleRespawn(cfg);
                }
                this.body.unshift(newHead);
                let targetLen = 3 + this.level;
                while (this.body.length > targetLen) this.body.pop();
            }
            gainXP(amount) {
                let finalXp = amount * this.xpMultiplier;
                this.xp += finalXp;
                this.totalAccumulatedXp += finalXp;
                while (this.xp >= this.maxXp) {
                    this.xp -= this.maxXp;
                    this.level++;
                    this.skillCharges++;
                    this.maxXp = Math.floor(this.maxXp * 1.2);
                    this.currentSpeedThreshold = this.currentSpeedThreshold / SPEED_INCREASE_FACTOR;
                    showMsg(this.id, "LEVEL UP!");
                    if (this.isAI) this.tryAutoCastSkill();
                }
            }
            useSkill(targetSnake) {
                if (this.skillCharges > 0) {
                    this.skillCharges--;
                    targetSnake.applyBlind();
                    return true;
                }
                return false;
            }
        }

        function showMsg(playerId, text) {
            let el = document.getElementById(`p${playerId}-msg`);
            el.innerText = text; el.style.opacity = '1';
            if (el.timeout) clearTimeout(el.timeout);
            el.timeout = setTimeout(() => { el.style.opacity = '0'; }, 1500);
        }

        function resize() {
            const container = document.getElementById('game-area');
            let padX = 40; let padY = 40;
            let availW = container.clientWidth - padX;
            let availH = container.clientHeight - padY;

            const radios = document.getElementsByName('map_mode');
            for(let r of radios) { if(r.checked) MAP_MODE = r.value; }

            if (MAP_MODE === 'fixed') {
                // Âº∑Âà∂ 30x12
                GRID_W = 30;
                GRID_H = 12;
                // Ë®àÁÆóÈÅ©ÂêàÁöÑ CELL_SIZE
                let sizeW = availW / GRID_W;
                let sizeH = availH / GRID_H;
                CELL_SIZE = Math.min(sizeW, sizeH);
                // ÈôêÂà∂ÊúÄÂ§ß‰ª•ÂÖçÂú®Ë∂ÖÂ§ßËû¢ÂπïÂ§™Èõ£ÁúãÔºåÊàñËÄÖËÆìÂÆÉ‰øùÊåÅÊ∏ÖÊô∞
                if(CELL_SIZE > 60) CELL_SIZE = 60;
                if(CELL_SIZE < 10) CELL_SIZE = 10;
            } else {
                // ÊúÄÂ§ßÂåñ
                CELL_SIZE = CELL_SIZE_BASE;
                GRID_W = Math.floor(availW / CELL_SIZE);
                GRID_H = Math.floor(availH / CELL_SIZE);
            }

            canvas.width = GRID_W * CELL_SIZE;
            canvas.height = GRID_H * CELL_SIZE;
            shadowCanvas.width = canvas.width;
            shadowCanvas.height = canvas.height;
        }

        function getSafePos() {
            let x, y, attempts = 0;
            do {
                x = Math.floor(Math.random() * GRID_W);
                y = Math.floor(Math.random() * GRID_H);
                attempts++;
            } while (items.some(i => i.x === x && i.y === y) && attempts < 100);
            return { x, y };
        }

        function initGame() {
            // ‰øùÂ≠òÁï∂ÂâçË®≠ÂÆö
            localStorage.setItem('sr_p1_ai', p1AiToggle.checked);
            localStorage.setItem('sr_p2_ai', p2AiToggle.checked);

            resize();
            let centerY = Math.floor(GRID_H / 2);
            const totalCells = GRID_W * GRID_H;

            const xp5Config = ITEM_CONFIG.find(c => c.id === 'xp5');
            if (xp5Config) xp5Config.count = Math.floor(totalCells * 0.15);

            let p1Name = p1NameIn.value || "PLAYER 1";
            let p2Name = p2NameIn.value || "PLAYER 2";
            let p1c = p1ColorIn.value;
            let p2c = p2ColorIn.value;
            let p1IsAi = p1AiToggle.checked;
            let p2IsAi = p2AiToggle.checked;

            if (p1IsAi) { p1Name = "AI (P1)"; p1NameIn.value = "AI (P1)"; }
            if (p2IsAi) { p2Name = "AI (P2)"; p2NameIn.value = "AI (P2)"; }

            // ËÆìË≥ΩÈÇèËºØÔºöÂ¶ÇÊûú‰∏ÄÂÄãÊòØ‰∫∫Ôºå‰∏ÄÂÄãÊòØAI
            let isMixedMatch = (p1IsAi !== p2IsAi);

            snakes = [
                new Snake(1, p1Name, 3, centerY, 1, 0, p1c, p1IsAi),
                new Snake(2, p2Name, GRID_W - 4, centerY, -1, 0, p2c, p2IsAi)
            ];

            if (isMixedMatch) {
                if (p1IsAi) snakes[0].startDelay = AI_HANDICAP_SECONDS;
                if (p2IsAi) snakes[1].startDelay = AI_HANDICAP_SECONDS;
            }

            items = [];
            pendingSpawns = [];
            xpHistory = { times: [], p1: [], p2: [] };
            historyTimer = 0;
            xpHistory.times.push(0);
            xpHistory.p1.push(0);
            xpHistory.p2.push(0);

            timeLeft = GAME_DURATION;
            isGameOver = false;

            ITEM_CONFIG.forEach(cfg => {
                for (let i = 0; i < cfg.count; i++) spawnItemImmediate(cfg);
            });

            lastTime = performance.now();
        }

        function spawnItemImmediate(cfg) {
            let p = getSafePos();
            items.push({ x: p.x, y: p.y, def: cfg });
        }

        function scheduleRespawn(cfg) {
            if (cfg.delay > 0) pendingSpawns.push({ timer: cfg.delay, def: cfg });
            else spawnItemImmediate(cfg);
        }

        function startGame() {
            document.getElementById('start-content').classList.add('hidden');
            document.getElementById('overlay-screen').classList.add('hidden');
            
            // Èö±ËóèÂú∞ÂúñÈÅ∏Êìá UI
            document.querySelectorAll('input[name="map_mode"]').forEach(r => r.disabled = true);

            p1NameIn.disabled = true; p2NameIn.disabled = true;
            p1ColorIn.disabled = true; p2ColorIn.disabled = true;
            document.getElementById('p1-ai-label').classList.add('ai-hidden');
            document.getElementById('p2-ai-label').classList.add('ai-hidden');

            initGame();
            requestAnimationFrame(gameLoop);
        }

        function gameLoop(time) {
            if (isGameOver) return;
            let dt = (time - lastTime) / 1000;
            lastTime = time;
            timeLeft -= dt;

            // History Recording
            historyTimer += dt;
            if (historyTimer >= 0.5) {
                historyTimer = 0;
                let elapsed = GAME_DURATION - timeLeft;
                if (elapsed < 0) elapsed = 0;
                xpHistory.times.push(elapsed);
                xpHistory.p1.push(snakes[0].totalAccumulatedXp);
                xpHistory.p2.push(snakes[1].totalAccumulatedXp);
            }

            if (timeLeft <= 0) {
                timeLeft = 0;
                xpHistory.times.push(90);
                xpHistory.p1.push(snakes[0].totalAccumulatedXp);
                xpHistory.p2.push(snakes[1].totalAccumulatedXp);
                endGame();
            }

            let tDisplay = document.getElementById('timer-display');
            tDisplay.innerText = Math.ceil(timeLeft);
            if (timeLeft < 10) tDisplay.style.color = '#e74c3c';
            else tDisplay.style.color = '#fff';

            for (let i = pendingSpawns.length - 1; i >= 0; i--) {
                pendingSpawns[i].timer -= dt;
                if (pendingSpawns[i].timer <= 0) {
                    spawnItemImmediate(pendingSpawns[i].def);
                    pendingSpawns.splice(i, 1);
                }
            }

            snakes.forEach(s => s.update(dt));
            updateUI();
            draw();
            gameLoopId = requestAnimationFrame(gameLoop);
        }

        function updateUI() {
            // Èò≤Ê≠¢ÁµêÁÆóÁï´Èù¢Âæå UI ÂÜçÊ¨°Êõ¥Êñ∞Â∞éËá¥Èö±ËóèÊ®ôÁ±§ÈáçÁèæ
            if (isGameOver) return; 

            [0, 1].forEach(i => {
                let s = snakes[i];
                let pId = s.id;
                document.getElementById(`p${pId}-lv`).innerText = s.level;
                let pct = (s.xp / s.maxXp) * 100;
                document.getElementById(`p${pId}-bar`).style.width = pct + "%";
                document.getElementById(`p${pId}-charges`).innerText = s.skillCharges;
                let blindTag = document.getElementById(`p${pId}-blind-tag`);
                s.blindTimer > 0 ? blindTag.classList.remove('hidden') : blindTag.classList.add('hidden');
                let boostTag = document.getElementById(`p${pId}-boost-tag`);
                s.xpBoostTimer > 0 ? boostTag.classList.remove('hidden') : boostTag.classList.add('hidden');
                let waitTag = document.getElementById(`p${pId}-wait-tag`);
                if (s.startDelay > 0) {
                    waitTag.classList.remove('hidden');
                    waitTag.innerText = `WAITING ${Math.ceil(s.startDelay)}s`;
                } else waitTag.classList.add('hidden');
            });
        }

        function draw() {
            ctx.fillStyle = COMMON_COLORS.bg;
            ctx.fillRect(0, 0, canvas.width, canvas.height);
            drawGrid();

            // 1. Âú∞ÊùøË¶ñÈáé
            ctx.save();
            snakes.forEach(s => {
                if (s.deadTimer > 0) return;
                let head = s.body[0];
                let cx = head.x * CELL_SIZE + CELL_SIZE / 2;
                let cy = head.y * CELL_SIZE + CELL_SIZE / 2;
                let radiusGrid = VISION_BASE_DIST + (s.level - 1) * VISION_PER_LV_DIST;
                if (s.blindTimer > 0) radiusGrid *= BLIND_FACTOR;
                if (s.startDelay > 0) radiusGrid = 2.0;
                let radiusPx = radiusGrid * CELL_SIZE;
                let spreadDeg = VISION_BASE_ANGLE + (s.level - 1) * VISION_PER_LV_ANGLE;
                let facingAngle = Math.atan2(s.dir.y, s.dir.x);
                ctx.beginPath();
                ctx.moveTo(cx, cy);
                ctx.arc(cx, cy, radiusPx, facingAngle - spreadDeg * (Math.PI / 360), facingAngle + spreadDeg * (Math.PI / 360));
                ctx.lineTo(cx, cy);
                ctx.fillStyle = 'rgba(255, 50, 50, 0.15)';
                ctx.fill();
            });
            ctx.restore();

            // 2. ÈÅìÂÖ∑
            ctx.textAlign = "center"; ctx.textBaseline = "middle";
            items.forEach(it => {
                let cx = it.x * CELL_SIZE + CELL_SIZE / 2;
                let cy = it.y * CELL_SIZE + CELL_SIZE / 2;
                let type = it.def.type;
                ctx.shadowBlur = 0;
                if (type === 'skill') {
                    ctx.font = "900 " + (CELL_SIZE*0.8) + "px Roboto";
                    ctx.fillStyle = it.def.color;
                    ctx.shadowBlur = 15; ctx.shadowColor = 'red';
                    ctx.fillText("Q", cx, cy);
                } else if (type === 'buffE') {
                    ctx.font = "900 " + (CELL_SIZE*0.85) + "px Roboto";
                    ctx.fillStyle = it.def.color;
                    ctx.shadowBlur = 15; ctx.shadowColor = '#0055ff';
                    ctx.fillText("E", cx, cy);
                } else if (type === 'chaos') {
                    ctx.font = (CELL_SIZE*0.8) + "px sans-serif";
                    ctx.fillStyle = it.def.color;
                    ctx.fillText("üîÑ", cx, cy);
                } else {
                    ctx.fillStyle = it.def.color;
                    let fontSize = CELL_SIZE * 0.45;
                    if (it.def.val >= 30) fontSize = CELL_SIZE * 0.6;
                    ctx.font = `bold ${fontSize}px Roboto`;
                    if (it.def.val >= 30) { ctx.shadowBlur = 10; ctx.shadowColor = it.def.color; }
                    ctx.fillText(it.def.val, cx, cy);
                }
                ctx.shadowBlur = 0;
            });

            // 3. Ëõá
            snakes.forEach(s => {
                if (s.deadTimer > 0) return;
                ctx.fillStyle = s.color;
                if (s.startDelay > 0) ctx.globalAlpha = 0.5;
                if (s.xpBoostTimer > 0) { ctx.shadowBlur = 10; ctx.shadowColor = '#00ffff'; } else { ctx.shadowBlur = 0; }
                s.body.forEach((b, i) => {
                    ctx.fillRect(b.x * CELL_SIZE + 1, b.y * CELL_SIZE + 1, CELL_SIZE - 2, CELL_SIZE - 2);
                    if (i === 0) {
                        ctx.fillStyle = '#fff';
                        let ex = (b.x * CELL_SIZE + CELL_SIZE / 2) + s.dir.x * (CELL_SIZE*0.25);
                        let ey = (b.y * CELL_SIZE + CELL_SIZE / 2) + s.dir.y * (CELL_SIZE*0.25);
                        ctx.beginPath(); ctx.arc(ex, ey, CELL_SIZE*0.1, 0, Math.PI * 2); ctx.fill();
                        ctx.fillStyle = s.color;
                    }
                });
                ctx.shadowBlur = 0; ctx.globalAlpha = 1.0;
                if (s.startDelay > 0) {
                    let head = s.body[0];
                    let hx = head.x * CELL_SIZE + CELL_SIZE / 2;
                    let hy = head.y * CELL_SIZE - 10;
                    ctx.fillStyle = "#fff"; ctx.font = "bold 14px Roboto";
                    ctx.fillText(`${Math.ceil(s.startDelay)}`, hx, hy);
                }
            });

            drawShadowLayer();
        }

        function drawGrid() {
            ctx.strokeStyle = COMMON_COLORS.grid; ctx.lineWidth = 1;
            ctx.beginPath();
            for (let x = 0; x <= GRID_W; x++) { ctx.moveTo(x * CELL_SIZE, 0); ctx.lineTo(x * CELL_SIZE, canvas.height); }
            for (let y = 0; y <= GRID_H; y++) { ctx.moveTo(0, y * CELL_SIZE); ctx.lineTo(canvas.width, y * CELL_SIZE); }
            ctx.stroke();
        }

        function drawShadowLayer() {
            shadowCtx.clearRect(0, 0, canvas.width, canvas.height);
            shadowCtx.globalCompositeOperation = 'source-over';
            shadowCtx.fillStyle = COMMON_COLORS.shadow;
            shadowCtx.fillRect(0, 0, canvas.width, canvas.height);
            shadowCtx.globalCompositeOperation = 'destination-out';

            snakes.forEach(s => {
                if (s.deadTimer > 0) return;
                let head = s.body[0];
                let cx = head.x * CELL_SIZE + CELL_SIZE / 2;
                let cy = head.y * CELL_SIZE + CELL_SIZE / 2;
                let radiusGrid = VISION_BASE_DIST + (s.level - 1) * VISION_PER_LV_DIST;
                if (s.blindTimer > 0) radiusGrid *= BLIND_FACTOR;
                if (s.startDelay > 0) radiusGrid = 2.0;
                let radiusPx = radiusGrid * CELL_SIZE;
                let spreadDeg = VISION_BASE_ANGLE + (s.level - 1) * VISION_PER_LV_ANGLE;
                let facingAngle = Math.atan2(s.dir.y, s.dir.x);

                let g = shadowCtx.createRadialGradient(cx, cy, 0, cx, cy, radiusPx);
                if (s.blindTimer > 0) {
                    g.addColorStop(0, 'rgba(0,0,0,1)'); g.addColorStop(0.9, 'rgba(0,0,0,1)'); g.addColorStop(1, 'rgba(0,0,0,0)');
                } else {
                    g.addColorStop(0, 'rgba(0,0,0,1)'); g.addColorStop(0.7, 'rgba(0,0,0,0.8)'); g.addColorStop(1, 'rgba(0,0,0,0)');
                }
                shadowCtx.fillStyle = g;
                shadowCtx.beginPath();
                shadowCtx.moveTo(cx, cy);
                shadowCtx.arc(cx, cy, radiusPx, facingAngle - spreadDeg * (Math.PI / 360), facingAngle + spreadDeg * (Math.PI / 360));
                shadowCtx.lineTo(cx, cy);
                shadowCtx.fill();

                shadowCtx.fillStyle = 'rgba(0,0,0,1)';
                s.body.forEach(part => {
                    let px = part.x * CELL_SIZE + CELL_SIZE / 2;
                    let py = part.y * CELL_SIZE + CELL_SIZE / 2;
                    shadowCtx.beginPath(); shadowCtx.arc(px, py, CELL_SIZE * 0.7, 0, Math.PI * 2); shadowCtx.fill();
                });

                if (s.xpBoostTimer > 0) {
                    let glowR = 6 * CELL_SIZE;
                    let g2 = shadowCtx.createRadialGradient(cx, cy, 0, cx, cy, glowR);
                    g2.addColorStop(0, 'rgba(0,0,0,1)'); g2.addColorStop(1, 'rgba(0,0,0,0)');
                    shadowCtx.fillStyle = g2;
                    shadowCtx.beginPath(); shadowCtx.arc(cx, cy, glowR, 0, Math.PI * 2); shadowCtx.fill();
                }
            });
            ctx.drawImage(shadowCanvas, 0, 0);

            ctx.save();
            ctx.globalCompositeOperation = 'screen';
            snakes.forEach(s => {
                if (s.deadTimer > 0) return;
                let head = s.body[0];
                let cx = head.x * CELL_SIZE + CELL_SIZE / 2;
                let cy = head.y * CELL_SIZE + CELL_SIZE / 2;
                let radiusGrid = VISION_BASE_DIST + (s.level - 1) * VISION_PER_LV_DIST;
                if (s.blindTimer > 0) radiusGrid *= BLIND_FACTOR;
                if (s.startDelay > 0) radiusGrid = 2.0;
                let radiusPx = radiusGrid * CELL_SIZE;
                let spreadDeg = VISION_BASE_ANGLE + (s.level - 1) * VISION_PER_LV_ANGLE;
                let facingAngle = Math.atan2(s.dir.y, s.dir.x);

                let lightG = ctx.createRadialGradient(cx, cy, 0, cx, cy, radiusPx);
                lightG.addColorStop(0, 'rgba(255, 160, 40, 0.4)');
                lightG.addColorStop(0.6, 'rgba(255, 120, 0, 0.1)');
                lightG.addColorStop(1, 'rgba(0, 0, 0, 0)');
                ctx.fillStyle = lightG;
                ctx.beginPath();
                ctx.moveTo(cx, cy);
                ctx.arc(cx, cy, radiusPx, facingAngle - spreadDeg * (Math.PI / 360), facingAngle + spreadDeg * (Math.PI / 360));
                ctx.lineTo(cx, cy);
                ctx.fill();

                if (s.xpBoostTimer > 0) {
                    let glowR = 6 * CELL_SIZE;
                    let buffG = ctx.createRadialGradient(cx, cy, 0, cx, cy, glowR);
                    let cRgbaMid = hexToRgba(s.color, 0.4);
                    let cRgbaEnd = hexToRgba(s.color, 0);
                    buffG.addColorStop(0, cRgbaMid); buffG.addColorStop(1, cRgbaEnd);
                    ctx.fillStyle = buffG;
                    ctx.beginPath(); ctx.arc(cx, cy, glowR, 0, Math.PI * 2); ctx.fill();
                }
            });
            ctx.restore();
        }

        function getXpAtTime(playerIdx, timeSec) {
            let idx = -1;
            let minDiff = 999;
            for(let i=0; i<xpHistory.times.length; i++) {
                let diff = Math.abs(xpHistory.times[i] - timeSec);
                if(diff < minDiff) { minDiff = diff; idx = i; }
            }
            if(idx === -1) return 0;
            return playerIdx === 1 ? xpHistory.p1[idx] : xpHistory.p2[idx];
        }

        function endGame() {
            isGameOver = true;
            let s1 = snakes[0];
            let s2 = snakes[1];
            let winnerId = 0;
            let reason = "Time Up";

            if (s1.level > s2.level) { winnerId = 1; reason = "Higher Level"; }
            else if (s2.level > s1.level) { winnerId = 2; reason = "Higher Level"; }
            else {
                if (s1.xp > s2.xp) { winnerId = 1; reason = "More XP"; }
                else if (s2.xp > s1.xp) { winnerId = 2; reason = "More XP"; }
                else {
                    if (s1.stats.totalDist > s2.stats.totalDist) { winnerId = 1; reason = "Distance Traveled"; }
                    else if (s2.stats.totalDist > s1.stats.totalDist) { winnerId = 2; reason = "Distance Traveled"; }
                    else { winnerId = 0; reason = "Perfect Tie"; }
                }
            }

            p1NameIn.disabled = false; p2NameIn.disabled = false;
            p1ColorIn.disabled = false; p2ColorIn.disabled = false;
            document.querySelectorAll('input[name="map_mode"]').forEach(r => r.disabled = false);
            document.getElementById('p1-ai-label').classList.remove('ai-hidden');
            document.getElementById('p2-ai-label').classList.remove('ai-hidden');

            // --- ÁµêÁÆóÊôÇÂº∑Âà∂ÁßªÈô§ÊâÄÊúâÁãÄÊÖãÊèêÁ§∫ ‰∏¶ Ê∏ÖÈô§Ë®àÊôÇÂô® ---
            s1.blindTimer = 0; s2.blindTimer = 0;
            s1.xpBoostTimer = 0; s2.xpBoostTimer = 0;
            s1.startDelay = 0; s2.startDelay = 0;
            
            document.getElementById('p1-blind-tag').classList.add('hidden');
            document.getElementById('p2-blind-tag').classList.add('hidden');
            document.getElementById('p1-boost-tag').classList.add('hidden');
            document.getElementById('p2-boost-tag').classList.add('hidden');
            document.getElementById('p1-wait-tag').classList.add('hidden');
            document.getElementById('p2-wait-tag').classList.add('hidden');

            // --- Ë®àÁÆóÂàÜÊÆµÊï∏Êìö ---
            let intervals = [15, 30, 45, 60, 75, 90];
            let p1Segs = [];
            let p2Segs = [];
            let lastP1 = 0, lastP2 = 0;

            intervals.forEach(t => {
                let currP1 = getXpAtTime(1, t);
                let currP2 = getXpAtTime(2, t);
                p1Segs.push(Math.floor(currP1 - lastP1));
                p2Segs.push(Math.floor(currP2 - lastP2));
                lastP1 = currP1;
                lastP2 = currP2;
            });

            // --- ËôïÁêÜÊéíË°åÊ¶ú (ÂÉÖÂú® 30x12 Ê®°Âºè) ---
            if (MAP_MODE === 'fixed') {
                // Âà§Êñ∑ÊØîË≥ΩÈ°ûÂûã
                let matchType = '';
                if (!s1.isAI && !s2.isAI) matchType = 'pvp';
                else if (s1.isAI && s2.isAI) matchType = 'aivai';
                else matchType = 'pve';

                updateLeaderboard(matchType, s1, p1Segs);
                updateLeaderboard(matchType, s2, p2Segs);
            }

            showEndScreen(winnerId, reason, s1, s2, p1Segs, p2Segs);
        }

       function updateLeaderboard(type, player, segments) {
            let dbKey = 'sr_lb_' + type; // sr_lb_pvp, sr_lb_pve, sr_lb_aivai
            let raw = localStorage.getItem(dbKey);
            let lb = raw ? JSON.parse(raw) : [];

            // --- ‰øÆÊîπÈñãÂßãÔºöËá™ÂÆöÁæ©Êó•ÊúüÊ†ºÂºè ---
            const now = new Date();
            const pad = (n) => n.toString().padStart(2, '0');
            const dateStr = `${now.getFullYear()}-${pad(now.getMonth() + 1)}-${pad(now.getDate())}-${pad(now.getHours())}:${pad(now.getMinutes())}:${pad(now.getSeconds())}`;

            // Êñ∞Â¢ûË®òÈåÑ
            let record = {
                name: player.name,
                total: Math.floor(player.totalAccumulatedXp),
                segs: segments, 
                date: dateStr // ‰ΩøÁî®‰∏äÈù¢ÁîüÊàêÁöÑÊ†ºÂºè
            };
            // --- ‰øÆÊîπÁµêÊùü ---

            lb.push(record);
            // ÊéíÂ∫è (Total Desc)
            lb.sort((a, b) => b.total - a.total);
            // ÂèñÂâç 10
            lb = lb.slice(0, 10);
            
            localStorage.setItem(dbKey, JSON.stringify(lb));
        }

        function clearLeaderboard() {
            if(confirm('Á¢∫ÂÆöË¶ÅÊ∏ÖÈô§ÊâÄÊúâÊéíË°åÊ¶úË®òÈåÑÂóéÔºüÊ≠§Êìç‰ΩúÁÑ°Ê≥ïÂæ©Âéü„ÄÇ')) {
                localStorage.removeItem('sr_lb_pvp');
                localStorage.removeItem('sr_lb_pve');
                localStorage.removeItem('sr_lb_aivai');
                renderLeaderboard();
            }
        }

        function renderLeaderboard() {
            function fillTable(tbodyId, type) {
                const tbody = document.getElementById(tbodyId);
                tbody.innerHTML = '';
                let dbKey = 'sr_lb_' + type;
                let raw = localStorage.getItem(dbKey);
                let data = raw ? JSON.parse(raw) : [];

                if(data.length === 0) {
                    tbody.innerHTML = '<tr><td colspan="9" style="color:#666; font-style:italic; padding:10px;">No Records</td></tr>';
                    return;
                }
                data.forEach((row, idx) => {
                    let tr = document.createElement('tr');
                    let segHtml = '';
                    // È°ØÁ§∫ 6 ÂÄãÊÆµ (0-90s)
                    for(let i=0; i<6; i++) {
                        let val = (row.segs && row.segs[i] !== undefined) ? row.segs[i] : 0;
                        segHtml += `<td class="lb-seg">${val}</td>`;
                    }

             tr.innerHTML = `
                        <td style="color:${idx===0?'#f1c40f':'#888'}">${idx+1}</td>
                        <td class="lb-name">
                            <div style="font-weight:bold; font-size:14px;">${row.name}</div>
                            <div style="font-size:10px; color:#666; margin-top:2px; font-weight:normal;">${row.date}</div>
                        </td>
                        <td class="lb-total">${row.total}</td>
                        ${segHtml}
                    `;
                    tbody.appendChild(tr);
                });
            }

            fillTable('lb-pvp-body', 'pvp');
            fillTable('lb-pve-body', 'pve');
            fillTable('lb-aivai-body', 'aivai');
        }

        function showEndScreen(wId, reason, s1, s2, p1Segs, p2Segs) {
            let overlay = document.getElementById('overlay-screen');
            let startContent = document.getElementById('start-content');
            let endContent = document.getElementById('end-content');
            overlay.classList.remove('hidden');
            startContent.classList.add('hidden');
            endContent.classList.remove('hidden');

            let titleEl = document.getElementById('winner-title');
            let reasonEl = document.getElementById('win-reason');
            let mapSizeEl = document.getElementById('map-size-info');

            if (wId === 1) { titleEl.innerText = `${s1.name} WINS!`; titleEl.style.color = s1.color; }
            else if (wId === 2) { titleEl.innerText = `${s2.name} WINS!`; titleEl.style.color = s2.color; }
            else { titleEl.innerText = "DRAW GAME"; titleEl.style.color = "#aaa"; }
            
            reasonEl.innerText = `Victory by: ${reason}`;
            mapSizeEl.innerText = `MAP SIZE: ${GRID_W} x ${GRID_H}`;

            let tableHtml = `
                <div class="stat-row level-row">
                    <div class="p1-val" style="color:${s1.color}">${s1.level}</div>
                    <div class="stat-label">LEVEL</div>
                    <div class="p2-val" style="color:${s2.color}">${s2.level}</div>
                </div>
                <div class="stat-row">
                    <div class="p1-val" style="color:${s1.color}">${Math.floor(s1.xp)} / ${s1.maxXp}</div>
                    <div class="stat-label">XP</div>
                    <div class="p2-val" style="color:${s2.color}">${Math.floor(s2.xp)} / ${s2.maxXp}</div>
                </div>
            `;
            const itemRows = [
                { id: 'buffE', label: 'Buff EXP', color: ITEM_COLORS.buffE },
                { id: 'chaos', label: 'Skill (üîÑ)', color: ITEM_COLORS.chaos },
                { id: 'skill', label: 'Skill (Q)', color: ITEM_COLORS.skillQ },
                { id: 'xp99', label: 'EXP 99', color: ITEM_COLORS.xp99 },
                { id: 'xp30', label: 'EXP 30', color: ITEM_COLORS.xp30 },
                { id: 'xp20', label: 'EXP 20', color: ITEM_COLORS.xp20 },
                { id: 'xp15', label: 'EXP 15', color: ITEM_COLORS.xp15 },
                { id: 'xp5', label: 'EXP 5', color: ITEM_COLORS.xp5 }
            ];
            itemRows.forEach(row => {
                let c1 = s1.stats.items[row.id] || 0;
                let c2 = s2.stats.items[row.id] || 0;
                tableHtml += `
                    <div class="stat-row">
                        <div class="p1-val" style="color:#ccc">${c1}</div>
                        <div class="stat-label"><span class="item-dot" style="background:${row.color}"></span> ${row.label}</div>
                        <div class="p2-val" style="color:#ccc">${c2}</div>
                    </div>
                `;
            });
            tableHtml += `
                <div class="stat-row total-row">
                    <div class="p1-val" style="color:${s1.color}">${s1.stats.totalDist}</div>
                    <div class="stat-label">Á∏ΩÁßªÂãïË∑ùÈõ¢</div>
                    <div class="p2-val" style="color:${s2.color}">${s2.stats.totalDist}</div>
                </div>
            `;
            document.getElementById('stat-table').innerHTML = tableHtml;

            // --- Ê∏≤ÊüìÂàÜÊÆµË°®Ê†º (ÁßªÈô§‰∫Ü Gap Column) ---
            const segTable = document.getElementById('seg-table-body');
            let segHtml = `
                <thead>
                    <tr>
                        <th style="color:#888">Time Segment</th>
                        <th style="color:${s1.color}">${s1.name} Gain</th>
                        <th style="color:${s2.color}">${s2.name} Gain</th>
                    </tr>
                </thead>
                <tbody>
            `;
            const timeLabels = ["0-15s", "15-30s", "30-45s", "45-60s", "60-75s", "75-90s"];
            for(let i=0; i<6; i++) {
                let v1 = p1Segs[i];
                let v2 = p2Segs[i];
                
                // Highlight color logic
                let c1Style = v1 > v2 ? `color:${s1.color}; font-weight:bold` : '';
                let c2Style = v2 > v1 ? `color:${s2.color}; font-weight:bold` : '';

                segHtml += `
                    <tr>
                        <td>${timeLabels[i]}</td>
                        <td style="${c1Style}">${v1}</td>
                        <td style="${c2Style}">${v2}</td>
                    </tr>
                `;
            }
            segHtml += `</tbody>`;
            segTable.innerHTML = segHtml;

            // --- Ê∏≤ÊüìÊéíË°åÊ¶ú (30x12) ---
            const lbSection = document.getElementById('leaderboard-section');
            if (MAP_MODE === 'fixed') {
                lbSection.classList.remove('hidden');
                renderLeaderboard();
            } else {
                lbSection.classList.add('hidden');
            }

            drawChart(s1.color, s2.color);
        }

        function drawChart(c1, c2) {
            const chartC = document.getElementById('chartCanvas');
            chartC.width = chartC.clientWidth;
            chartC.height = chartC.clientHeight;
            const cCtx = chartC.getContext('2d');
            const w = chartC.width;
            const h = chartC.height;
            const padLeft = 60;
            const padBottom = 40;
            const padTop = 30;
            const padRight = 30;

            cCtx.clearRect(0, 0, w, h);

            let realMax = 0;
            xpHistory.p1.forEach(v => { if (v > realMax) realMax = v; });
            xpHistory.p2.forEach(v => { if (v > realMax) realMax = v; });
            let maxY = Math.max(realMax, 500);
            maxY = Math.ceil(maxY / 500) * 500;

            cCtx.font = 'bold 16px Roboto';
            cCtx.fillStyle = '#888';
            cCtx.strokeStyle = 'rgba(255, 255, 255, 0.1)';
            cCtx.lineWidth = 1;

            // X Axis
            for (let t = 0; t <= 90; t += 15) {
                let x = padLeft + (t / 90) * (w - padLeft - padRight);
                cCtx.beginPath(); cCtx.moveTo(x, padTop); cCtx.lineTo(x, h - padBottom); cCtx.stroke();
                cCtx.textAlign = 'center';
                cCtx.fillText(t + 's', x, h - padBottom + 25);
            }

            // Y Axis
            for (let xp = 0; xp <= maxY; xp += 500) {
                let y = (h - padBottom) - (xp / maxY) * (h - padBottom - padTop);
                cCtx.beginPath(); cCtx.moveTo(padLeft, y); cCtx.lineTo(w - padRight, y); cCtx.stroke();
                cCtx.textAlign = 'right';
                cCtx.fillText(xp, padLeft - 10, y + 5);
            }

            cCtx.strokeStyle = '#aaa';
            cCtx.lineWidth = 2;
            cCtx.beginPath();
            cCtx.moveTo(padLeft, padTop);
            cCtx.lineTo(padLeft, h - padBottom);
            cCtx.lineTo(w - padRight, h - padBottom);
            cCtx.stroke();

            function drawLine(data, color) {
                cCtx.beginPath();
                cCtx.strokeStyle = color;
                cCtx.lineWidth = 3; 
                for (let i = 0; i < xpHistory.times.length; i++) {
                    let t = xpHistory.times[i];
                    let val = data[i];
                    let x = padLeft + (t / 90) * (w - padLeft - padRight);
                    let y = (h - padBottom) - (val / maxY) * (h - padBottom - padTop);
                    if (i === 0) cCtx.moveTo(x, y); else cCtx.lineTo(x, y);
                }
                cCtx.stroke();
            }

            drawLine(xpHistory.p1, c1);
            drawLine(xpHistory.p2, c2);
        }
// --- AI Ê†∏ÂøÉÁÆóÊ≥ïÔºöÊ™¢Êü•ÊòØÂê¶ËÉΩÈÄöÂæÄÈÇäÁïå (ÂæåË∑ØÊ™¢Ê∏¨) ---
function checkEscapeRoute(startX, startY, currentSnakeId) {
    // Â¶ÇÊûúËµ∑ÈªûÊú¨Ë∫´Â∞±ÊòØÈÇäÁïåÔºåÁõ¥Êé•ÁÆóÂÆâÂÖ®
    if (startX === 0 || startX === GRID_W - 1 || startY === 0 || startY === GRID_H - 1) return true;

    // Âª∫Á´ã‰∏ÄÂÄãËá®ÊôÇÁöÑÁ¢∞ÊíûÁ∂≤Ê†ºÔºåÊ®ôË®òÊâÄÊúâÈöúÁ§ôÁâ©
    let visited = new Set();
    let queue = [{ x: startX, y: startY }];
    visited.add(`${startX},${startY}`);

    // Â∞áÊâÄÊúâËõáÁöÑË∫´È´îÊ®ôË®òÁÇ∫‰∏çÂèØÈÄöË°å (ÂåÖÊã¨Ëá™Â∑±ÁõÆÂâçÁöÑË∫´È´î)
    snakes.forEach(s => {
        s.body.forEach(b => {
            visited.add(`${b.x},${b.y}`);
        });
    });

    // ÁÇ∫‰∫ÜÊïàËÉΩÔºåÊàëÂÄëË®≠ÂÆöÊêúÁ¥¢‰∏äÈôê (‰æãÂ¶ÇÊêúÁ¥¢ 300 Ê†ºÈÇÑÊâæ‰∏çÂà∞ÈÇäÁïåÂ∞±ÁÆóÂ§±ÊïóÔºåÈÅøÂÖçÂ§ßÂúñÂç°È†ì)
    let searchLimit = 400; 
    let count = 0;

    const directions = [{ x: 0, y: -1 }, { x: 0, y: 1 }, { x: -1, y: 0 }, { x: 1, y: 0 }];

    while (queue.length > 0) {
        let curr = queue.shift();
        count++;
        if (count > searchLimit) return true; // ÊêúÁ¥¢ÁØÑÂúçÂ§†Â§ßÔºåÂÅáË®≠ÊòØÈñãÊîæÁ©∫Èñì

        // Ê™¢Êü• 4 ÂÄãÊñπÂêë
        for (let dir of directions) {
            let nx = curr.x + dir.x;
            let ny = curr.y + dir.y;

            // Á¢∞Âà∞ÈÇäÁïå‰∫ÜÔºÅ‰ª£Ë°®ÊúâÂæåË∑ØÔºåÂÆâÂÖ®
            if (nx < 0 || nx >= GRID_W || ny < 0 || ny >= GRID_H) return true;
            // ‰øÆÊ≠£ÔºöÂ¶ÇÊûúÁ¢∞Âà∞ÈÇäÁ∑£Â∫ßÊ®ô (0, W-1, etc) ‰πüÁÆóÂÆâÂÖ®
            if (nx === 0 || nx === GRID_W - 1 || ny === 0 || ny === GRID_H - 1) return true;

            let key = `${nx},${ny}`;
            if (!visited.has(key)) {
                visited.add(key);
                queue.push({ x: nx, y: ny });
            }
        }
    }

    // ÈöäÂàóË∑ëÂÆåÈÉΩÊ≤íÁ¢∞Âà∞ÈÇäÁïåÔºå‰ª£Ë°®Ë¢´ÂåÖÂúç‰∫Ü
    return false;
}
        function captureScreenshot() {
            const targetEl = document.querySelector("#capture-target");
            const btn = document.querySelector(".btn-blue");
            const originalText = btn.innerText;
            btn.innerText = "üì∏ Processing...";
            btn.style.opacity = "0.7";
            btn.disabled = true;

            html2canvas(targetEl, {
                backgroundColor: "#0b0b0b", scale: 2, logging: false, useCORS: true
            }).then(canvas => {
                canvas.toBlob(blob => {
                    if (!blob) { resetBtn(btn, originalText); alert("Error"); return; }
                    try {
                        const item = new ClipboardItem({ "image/png": blob });
                        navigator.clipboard.write([item]).then(() => { resetBtn(btn, originalText); })
                        .catch(err => { triggerDownload(canvas); resetBtn(btn, originalText); });
                    } catch (e) { triggerDownload(canvas); resetBtn(btn, originalText); }
                });
            }).catch(err => { console.error(err); resetBtn(btn, originalText); });
        }
        function triggerDownload(canvas) {
            const link = document.createElement('a');
            const now = new Date();
            const timeStr = now.toISOString().slice(0, 19).replace(/[-T:]/g, "");
            link.download = `ShadowRacing_${timeStr}.png`;
            link.href = canvas.toDataURL("image/png");
            link.click();
        }
        function resetBtn(btn, originalText) {
            btn.innerText = originalText; btn.style.opacity = "1"; btn.disabled = false;
        }

        window.addEventListener('keydown', e => {
            let isEndScreen = !document.getElementById('end-content').classList.contains('hidden');
            let isStartScreen = !document.getElementById('start-content').classList.contains('hidden');
            if (document.activeElement.tagName === "INPUT") return;
            if (isStartScreen && e.key === 'Enter') { startGame(); return; }
            if (isEndScreen && (e.key === 'r' || e.key === 'R')) { location.reload(); return; }
            if (!isGameOver && !isStartScreen) {
                // P1
                if (!snakes[0].isAI) {
                    if (e.key === 'w' && snakes[0].dir.y === 0) snakes[0].nextDir = { x: 0, y: -1 };
                    if (e.key === 's' && snakes[0].dir.y === 0) snakes[0].nextDir = { x: 0, y: 1 };
                    if (e.key === 'a' && snakes[0].dir.x === 0) snakes[0].nextDir = { x: -1, y: 0 };
                    if (e.key === 'd' && snakes[0].dir.x === 0) snakes[0].nextDir = { x: 1, y: 0 };
                    if ((e.key === 'q' || e.key === 'Q')) snakes[0].useSkill(snakes[1]);
                }
                // P2
                if (!snakes[1].isAI) {
                    if (e.key === 'ArrowUp' && snakes[1].dir.y === 0) snakes[1].nextDir = { x: 0, y: -1 };
                    if (e.key === 'ArrowDown' && snakes[1].dir.y === 0) snakes[1].nextDir = { x: 0, y: 1 };
                    if (e.key === 'ArrowLeft' && snakes[1].dir.x === 0) snakes[1].nextDir = { x: -1, y: 0 };
                    if (e.key === 'ArrowRight' && snakes[1].dir.x === 0) snakes[1].nextDir = { x: 1, y: 0 };
                    if (e.key === 'Enter') snakes[1].useSkill(snakes[0]);
                }
            }
        });

        window.addEventListener('resize', () => { if (!isGameOver) resize(); });
    </script>
</body>
</html>
