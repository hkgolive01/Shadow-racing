<!DOCTYPE html>
<html lang="zh-HK">

<head>
    <meta charset="UTF-8">
    <title>Shadow Racing - Ultimate Edition</title>
    <script src="https://html2canvas.hertzen.com/dist/html2canvas.min.js"></script>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=sans-serif:wght@400;700;900&family=Roboto:wght@400;700;900&display=swap');

        body {
            background-color: #050505;
            color: #ecf0f1;
            font-family: 'Roboto', sans-serif;
            display: flex;
            flex-direction: column;
            height: 100vh;
            margin: 0;
            overflow: hidden;
            user-select: none;
        }

        /* --- UI BAR --- */
        #ui-bar {
            height: 140px;
            background: #0b0b0b;
            border-bottom: 2px solid #333;
            display: flex;
            justify-content: space-between;
            align-items: flex-start;
            padding: 10px 30px 0 30px;
            box-shadow: 0 5px 20px rgba(0, 0, 0, 0.9);
            z-index: 10;
            flex-shrink: 0;
        }

        .center-display {
            text-align: center;
            width: 200px;
            margin-top: 10px;
        }

        #timer-display {
            font-family: 'Roboto', sans-serif;
            font-size: 70px;
            color: #fff;
            text-shadow: 0 0 15px rgba(255, 255, 255, 0.4);
            line-height: 1;
        }

        .timer-label {
            font-size: 14px;
            color: #666;
            letter-spacing: 2px;
            margin-top: 5px;
        }

        .player-info {
            display: flex;
            flex-direction: column;
            width: 380px;
            font-family: 'Roboto', sans-serif;
            position: relative;
            transition: color 0.3s, border-color 0.3s;
        }

        .p1-info {
            border-left: 4px solid;
            padding-left: 20px;
        }

        .p2-info {
            border-right: 4px solid;
            padding-right: 20px;
            text-align: right;
            align-items: flex-end;
        }

        .input-group {
            display: flex;
            align-items: center;
            gap: 10px;
            margin-bottom: 2px;
            flex-wrap: wrap;
        }

        .p2-info .input-group {
            flex-direction: row-reverse;
        }

        .name-input {
            background: transparent;
            border: 1px solid transparent;
            color: inherit;
            font-family: 'Roboto', sans-serif;
            font-size: 20px;
            font-weight: bold;
            width: 150px;
            padding: 2px 0;
            border-radius: 4px;
            outline: none;
            transition: 0.2s;
        }

        .name-input:hover {
            border-color: #333;
            cursor: pointer;
        }

        .name-input:focus {
            border-color: #fff;
            background: #222;
            cursor: text;
        }

        .p2-info .name-input {
            text-align: right;
        }

        .color-picker {
            -webkit-appearance: none;
            border: none;
            width: 20px;
            height: 20px;
            cursor: pointer;
            background: none;
            padding: 0;
        }

        .color-picker::-webkit-color-swatch-wrapper {
            padding: 0;
        }

        .color-picker::-webkit-color-swatch {
            border: 2px solid #555;
            border-radius: 50%;
        }

        .ai-label {
            display: flex;
            align-items: center;
            gap: 5px;
            font-size: 12px;
            font-weight: bold;
            color: #888;
            cursor: pointer;
            border: 1px solid #333;
            padding: 2px 6px;
            border-radius: 4px;
            transition: 0.2s;
        }

        .ai-label:hover {
            border-color: #666;
            color: #fff;
        }

        .ai-checkbox {
            cursor: pointer;
        }

        .ai-hidden {
            display: none !important;
        }

        .stats-row-composite {
            display: flex;
            align-items: baseline;
            gap: 25px;
            margin-top: -5px;
        }

        .p2-info .stats-row-composite {
            flex-direction: row-reverse;
        }

        .big-stat {
            display: flex;
            align-items: baseline;
            gap: 5px;
        }

        .stat-label {
            font-size: 14px;
            color: #666;
            font-weight: bold;
        }

        .stat-val {
            font-size: 48px;
            font-weight: 900;
            line-height: 1;
        }

        .skill-val {
            font-size: 32px;
            color: #f1c40f;
            text-shadow: 0 0 10px rgba(241, 196, 15, 0.2);
        }

        .bar-bg {
            width: 100%;
            height: 8px;
            background: #333;
            margin-top: 5px;
            border-radius: 4px;
            overflow: hidden;
            position: relative;
        }

        .xp-bar {
            height: 100%;
            transition: width 0.2s;
        }

        .player-msg {
            height: 20px;
            margin-top: 4px;
            font-size: 14px;
            font-weight: bold;
            text-transform: uppercase;
            letter-spacing: 1px;
            opacity: 0;
            transition: opacity 0.3s;
        }

        .status-badge {
            padding: 1px 4px;
            border-radius: 2px;
            font-size: 10px;
            font-weight: bold;
            box-shadow: 0 0 5px currentColor;
            display: inline-block;
            margin: 0 2px;
        }

        .blind-badge {
            background: #fff;
            color: #000;
            animation: flash 0.5s infinite;
        }

        .boost-badge {
            background: #0055ff;
            color: #fff;
            border: 1px solid #00ffff;
            box-shadow: 0 0 10px #0055ff;
            animation: pulse-blue 1s infinite;
        }

        .wait-badge {
            background: #e67e22;
            color: #fff;
            border: 1px solid #d35400;
            box-shadow: 0 0 10px #e67e22;
        }

        @keyframes flash {
            0% {
                opacity: 1;
            }

            50% {
                opacity: 0.5;
            }

            100% {
                opacity: 1;
            }
        }

        @keyframes pulse-blue {
            0% {
                box-shadow: 0 0 5px #0055ff;
            }

            50% {
                box-shadow: 0 0 15px #00ffff;
            }

            100% {
                box-shadow: 0 0 5px #0055ff;
            }
        }

        /* --- GAME AREA --- */
        #game-area {
            flex-grow: 1;
            position: relative;
            background: #000;
            width: 100%;
            overflow: hidden;
            display: flex;
            justify-content: center;
            align-items: center;
            padding: 20px;
            box-sizing: border-box;
        }

        canvas {
            display: block;
            background-color: #111;
            border: 3px solid #444;
            box-shadow: 0 0 50px rgba(0, 0, 0, 0.8);
        }

        /* --- OVERLAY SCREENS --- */
        #overlay-screen {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(5, 5, 5, 0.98);
            display: flex;
            flex-direction: column;
            justify-content: flex-start;
            align-items: center;
            z-index: 100;
            transition: opacity 0.3s;
            overflow-y: auto;
            padding-top: 10px;
        }

        #start-content,
        #end-content {
            display: flex;
            flex-direction: column;
            align-items: center;
            width: 100%;
            padding: 20px 0;
        }

        h1 {
            font-family: 'Roboto', sans-serif;
            font-size: 64px;
            background: linear-gradient(to right, #2ecc71, #f1c40f);
            -webkit-background-clip: text;
            color: transparent;
            margin-bottom: 20px;
            letter-spacing: 5px;
            text-transform: uppercase;
            text-align: center;
            text-indent: 5px;
        }

        #capture-target {
            display: flex;
            flex-direction: column;
            align-items: center;
            width: 96%;
            max-width: none;
            background: #0b0b0b;
            padding: 30px;
            border-radius: 10px;
            margin-bottom: 20px;
            box-sizing: border-box;
        }

        .content-box {
            background: rgba(255, 255, 255, 0.05);
            padding: 30px 40px;
            border-radius: 12px;
            border: 1px solid #333;
            width: 100%;
            text-align: left;
            box-sizing: border-box;
        }

        #start-content .content-box {
            width: 96%;
            /* Ë®≠ÂÆöÂØ¨Â∫¶‰ΩîËû¢Âπï 96% */
            max-width: none;
            /* ÁßªÈô§ÊúÄÂ§ßÂØ¨Â∫¶ÈôêÂà∂ */
            margin-bottom: 20px;
        }

        .rule-title {
            color: #f1c40f;
            font-weight: bold;
            font-size: 20px;
            margin-bottom: 10px;
            font-family: 'sans-serif';
            border-bottom: 1px solid #444;
            padding-bottom: 5px;
        }

        .rule-row {
            display: flex;
            margin-bottom: 10px;
            align-items: center;
        }

        .icon {
            width: 40px;
            font-size: 24px;
            text-align: center;
            margin-right: 15px;
        }

        .desc {
            color: #ccc;
            font-size: 16px;
            line-height: 1.4;
        }

        /* --- MAP SELECTION --- */
        .map-select-row {
            display: flex;
            justify-content: center;
            gap: 40px;
            margin: 20px 0;
            padding: 15px;
            background: rgba(255, 255, 255, 0.05);
            border-radius: 8px;
            border: 1px solid #444;
        }

        .map-option {
            display: flex;
            align-items: center;
            gap: 10px;
            cursor: pointer;
            font-size: 18px;
            color: #ddd;
        }

        .map-option input {
            transform: scale(1.5);
            accent-color: #2ecc71;
            cursor: pointer;
        }

        /* --- RESULTS --- */
        .result-header {
            text-align: center;
            margin-bottom: 20px;
            width: 100%;
        }

        .winner-announce {
            font-size: 72px;
            font-weight: 900;
            font-family: 'sans-serif';
            margin-bottom: 10px;
            text-shadow: 0 0 25px currentColor;
        }

        .reason-text {
            color: #aaa;
            font-size: 28px;
            margin-bottom: 20px;
            font-style: italic;
        }

        .stat-grid {
            display: flex;
            flex-direction: column;
            width: 100%;
            gap: 0;
        }

        .stat-row {
            display: grid;
            grid-template-columns: 1fr 200px 1fr;
            align-items: center;
            border-bottom: 1px solid rgba(255, 255, 255, 0.1);
            padding: 10px 0;
            transition: background 0.2s;
        }

        .stat-row:hover {
            background: rgba(255, 255, 255, 0.02);
        }

        .stat-label {
            color: #888;
            text-align: center;
            font-size: 20px;
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 10px;
            white-space: nowrap;
        }

        .p1-val,
        .p2-val {
            font-family: 'sans-serif';
            font-weight: bold;
            text-align: center;
            font-size: 24px;
        }

        .level-row {
            padding: 15px 0;
            border-bottom: 2px solid #444;
            margin-bottom: 15px;
        }

        .level-row .p1-val,
        .level-row .p2-val {
            font-size: 5rem;
            text-shadow: 0 0 20px currentColor;
        }

        .level-row .stat-label {
            font-size: 2rem;
            color: #fff;
            font-weight: bold;
        }

        .total-row {
            border-top: 2px solid #555;
            border-bottom: none;
            margin-top: 20px;
            padding-top: 20px;
        }

        .total-row .stat-label,
        .total-row .p1-val,
        .total-row .p2-val {
            font-size: 24px;
            color: #fff;
        }

        .item-dot {
            width: 14px;
            height: 14px;
            display: inline-block;
            border-radius: 50%;
        }

        .btn-container {
            text-align: center;
            margin-top: 10px;
        }

        .btn {
            margin: 10px;
            padding: 15px 40px;
            font-size: 20px;
            font-family: 'Roboto', sans-serif;
            background: transparent;
            color: #2ecc71;
            border: 2px solid #2ecc71;
            cursor: pointer;
            transition: 0.2s;
            border-radius: 5px;
        }

        .btn:hover {
            background: #2ecc71;
            color: #000;
            box-shadow: 0 0 20px #2ecc71;
        }

        .btn-blue {
            color: #3498db;
            border-color: #3498db;
        }

        .btn-blue:hover {
            background: #3498db;
            color: #fff;
            box-shadow: 0 0 20px #3498db;
        }

        .btn-red-sm {
            padding: 6px 12px;
            font-size: 14px;
            color: #e74c3c;
            border: 1px solid #e74c3c;
            background: transparent;
            cursor: pointer;
            border-radius: 4px;
            margin-left: 15px;
            vertical-align: middle;
        }

        .btn-red-sm:hover {
            background: #e74c3c;
            color: white;
        }

        .hidden {
            display: none !important;
        }

        /* --- CHART & ANALYSIS --- */
        #chart-container {
            width: 100%;
            height: 400px;
            margin-top: 30px;
            background: rgba(0, 0, 0, 0.3);
            border: 1px solid #333;
            border-radius: 8px;
            padding: 15px;
            box-sizing: border-box;
        }

        #chartCanvas {
            width: 100%;
            height: 100%;
        }

        /* Segment Table Styles */
        #segment-analysis,
        #leaderboard-section,
        #leaderboard-section-start {
            width: 100%;
            margin-top: 40px;
        }

        .section-title {
            color: #f1c40f;
            font-size: 24px;
            font-weight: bold;
            margin-bottom: 15px;
            border-left: 6px solid #f1c40f;
            padding-left: 15px;
            display: flex;
            align-items: center;
            justify-content: space-between;
        }

        .analysis-table,
        .lb-table {
            width: 100%;
            border-collapse: collapse;
            font-size: 18px;
            text-align: center;
        }

        .analysis-table th,
        .analysis-table td,
        .lb-table th,
        .lb-table td {
            border: 1px solid #333;
            padding: 12px 8px;
            color: #ccc;
        }

        .analysis-table th,
        .lb-table th {
            background: rgba(255, 255, 255, 0.05);
            color: #fff;
            font-weight: bold;
            font-size: 20px;
        }

        .win-seg {
            color: #2ecc71;
            font-weight: bold;
        }

        .lose-seg {
            color: #e74c3c;
        }

        /* Leaderboard Specifics */
        .lb-container {
            display: flex;
            gap: 20px;
            margin-top: 15px;
        }

        .lb-box {
            flex: 1;
            background: rgba(0, 0, 0, 0.4);
            padding: 15px;
            border-radius: 8px;
            border: 1px solid #333;
            overflow-x: auto;
            min-width: 0;
        }

        .lb-header {
            text-align: center;
            font-weight: bold;
            color: #ccc;
            margin-bottom: 12px;
            text-transform: uppercase;
            font-size: 18px;
            border-bottom: 1px solid #444;
            padding-bottom: 8px;
        }

        .lb-header.pvp {
            color: #2ecc71;
        }

        .lb-header.pve {
            color: #f39c12;
        }

        .lb-header.aivai {
            color: #e74c3c;
        }

        .lb-table {
            font-size: 14px;
        }

        .lb-table th,
        .lb-table td {
            padding: 6px 4px;
        }

        .lb-rank {
            width: 30px;
            color: #888;
            font-size: 16px;
        }

        .lb-name {
            text-align: left;
            max-width: 80px;
            overflow: hidden;
            text-overflow: ellipsis;
            white-space: nowrap;
            font-weight: bold;
            font-size: 15px;
        }

        .lb-total {
            color: #f1c40f;
            font-weight: bold;
            width: 50px;
            font-size: 16px;
        }

        .lb-seg {
            font-size: 13px;
            color: #999;
            width: 35px;
        }

        ::-webkit-scrollbar {
            width: 8px;
            height: 8px;
        }

        ::-webkit-scrollbar-track {
            background: #000;
        }

        ::-webkit-scrollbar-thumb {
            background: #333;
            border-radius: 4px;
        }

        ::-webkit-scrollbar-thumb:hover {
            background: #555;
        }
    </style>
</head>

<body>

    <div id="ui-bar">
        <div class="player-info p1-info" id="p1-panel">
            <div class="input-group">
                <input type="text" id="p1-name-in" value="PLAYER 1" class="name-input" maxlength="12">
                <input type="color" id="p1-color-in" value="#3498db" class="color-picker">
                <label class="ai-label" id="p1-ai-label">
                    <input type="checkbox" id="p1-ai-toggle" class="ai-checkbox"> AI
                </label>
                <span id="p1-blind-tag" class="status-badge blind-badge hidden">BLINDED</span>
                <span id="p1-boost-tag" class="status-badge boost-badge hidden">XP BOOST</span>
                <span id="p1-wait-tag" class="status-badge wait-badge hidden">WAITING</span>
            </div>

            <div class="stats-row-composite">
                <div class="big-stat">
                    <span class="stat-label">LV</span>
                    <span id="p1-lv" class="stat-val">1</span>
                </div>
                <div class="big-stat">
                    <span class="stat-label">[Q]</span>
                    <span id="p1-charges" class="stat-val skill-val">0</span>
                </div>
            </div>

            <div class="bar-bg">
                <div id="p1-bar" class="xp-bar" style="width:0%"></div>
            </div>
            <div id="p1-msg" class="player-msg"></div>
        </div>

        <div class="center-display">
            <div id="timer-display">90</div>
            <div class="timer-label">SECONDS LEFT</div>
        </div>

        <div class="player-info p2-info" id="p2-panel">
            <div class="input-group">
                <input type="text" id="p2-name-in" value="PLAYER 2" class="name-input" maxlength="12">
                <input type="color" id="p2-color-in" value="#e74c3c" class="color-picker">
                <label class="ai-label" id="p2-ai-label">
                    <input type="checkbox" id="p2-ai-toggle" class="ai-checkbox"> AI
                </label>
                <span id="p2-blind-tag" class="status-badge blind-badge hidden">BLINDED</span>
                <span id="p2-boost-tag" class="status-badge boost-badge hidden">XP BOOST</span>
                <span id="p2-wait-tag" class="status-badge wait-badge hidden">WAITING</span>
            </div>

            <div class="stats-row-composite">
                <div class="big-stat">
                    <span class="stat-label">LV</span>
                    <span id="p2-lv" class="stat-val">1</span>
                </div>
                <div class="big-stat">
                    <span class="stat-label">[ENTER]</span>
                    <span id="p2-charges" class="stat-val skill-val">0</span>
                </div>
            </div>

            <div class="bar-bg">
                <div id="p2-bar" class="xp-bar" style="width:0%"></div>
            </div>
            <div id="p2-msg" class="player-msg"></div>
        </div>
    </div>

    <div id="game-area">
        <canvas id="gameCanvas"></canvas>

        <div id="overlay-screen">
            <div id="start-content">
                <h1>Shadow Racing</h1>

                <div class="map-select-row">
                    <label class="map-option">
                        <input type="radio" name="map_mode" value="fixed" checked>
                        Âõ∫ÂÆöÂú∞Âúñ (30x12) <span style="font-size:12px; color:#888;">(ÊéíË°åÊ¶úÊúâÊïà)</span>
                    </label>
                    <label class="map-option">
                        <input type="radio" name="map_mode" value="fill">
                        ÊúÄÂ§ßÂåñ (Â°´ÊªøÁï´Èù¢)
                    </label>
                </div>

                <div class="content-box">
                    <div class="rule-title">ÈÅìÂÖ∑ËàáË¶èÂâá</div>
                    <div class="rule-row"><span class="icon">üî¢</span><span
                            class="desc">ÂêÉÊéâÊï∏Â≠óÂ¢ûÂä†Á∂ìÈ©ó„ÄÇ<strong>ÊØèÂçá‰∏ÄÁ¥öÔºåË¶ñÈáéÂ¢ûÂä†ÔºåÁßªÂãïÈÄüÂ∫¶ÊèêÂçáÔºåÈï∑Â∫¶Â¢ûÂä†ÔºÅ</strong></span></div>
                    <div class="rule-row"><span class="icon" style="color:red; font-weight:bold">Q</span><span
                            class="desc">Áç≤ÂæóËá¥Áõ≤ÊäÄËÉΩ (Â∞çÊâãË¶ñÈáéÂâ© 40% / 3Áßí)„ÄÇ<strong>AI Áç≤ÂæóÂæåÊúÉËá™ÂãïÊñΩÊîæ„ÄÇ</strong></span></div>
                    <div class="rule-row"><span class="icon"
                            style="color:#00ffff; font-weight:bold; text-shadow:0 0 5px #0055ff">E</span><span
                            class="desc"><strong>XP BOOSTÔºö</strong> Áç≤ÂæóÈ°çÂ§ñ 50% Á∂ìÈ©óÂÄº (ÊåÅÁ∫å 5 Áßí)Ôºå<strong>‰∏¶ÁôºÂá∫Ëá™Ë∫´È°èËâ≤ÁöÑÂÖâËäí</strong>„ÄÇAI
                            Â∞áÂÑ™ÂÖàÁà≠Â•™Ê≠§ÈÅìÂÖ∑ÔºÅ</span></div>
                    <div class="rule-row"><span class="icon" style="font-size:20px">üîÑ</span><span
                            class="desc"><strong>Ê∑∑‰∫ÇÂ∞çÊâãÔºö</strong> ËÆìÂ∞çÊâã<strong>Âº∑Âà∂ 90 Â∫¶ËΩâÂêë</strong> (Èö®Ê©ü)„ÄÇ</span></div>

                    <div class="rule-title" style="margin-top:15px">Êìç‰ΩúËàá AI ËÆìË≥Ω</div>
                    <div class="rule-row"><span class="icon" style="color:#3498db">P1</span><span class="desc"><strong>W
                                A S D</strong> ÁßªÂãï„ÄÇ <strong>Q Èçµ</strong>ÔºöËá¥Áõ≤„ÄÇ<br>(Ëã•ÈñãÂïüAIÔºåÂâáËá™ÂãïÊìç‰Ωú)</span></div>
                    <div class="rule-row"><span class="icon" style="color:#e74c3c">P2</span><span
                            class="desc"><strong>ÊñπÂêëÈçµ</strong> ÁßªÂãï„ÄÇ <strong>Enter Èçµ</strong>ÔºöËá¥Áõ≤„ÄÇ<br>(Ëã•ÈñãÂïüAIÔºåÂâáËá™ÂãïÊìç‰Ωú)</span>
                    </div>
                    <div class="rule-row"><span class="icon">ü§ñ</span><span class="desc"
                            style="color:#e67e22"><strong>‰∫∫Ê©üÂ∞çÊà∞Ë¶èÂâáÔºö</strong> Ëã•‰∏ÄÊñπÁÇ∫‰∫∫È°ûÔºå‰∏ÄÊñπÁÇ∫ AIÔºå<strong>AI Â∞áÊúÉËÆìË≥Ω 45
                                ÁßíÔºàÂéüÂú∞ÈùúÊ≠¢Ôºâ</strong>„ÄÇ</span></div>
                </div>

                <div id="leaderboard-section-start" style="width: 96%; max-width: none; margin-bottom: 20px;">
                    <div class="section-title">
                        30x12 Ê®°ÂºèÊéíË°åÊ¶ú (TOP 10)
                        <button onclick="clearLeaderboard()" class="btn-red-sm">üóëÔ∏è Ê∏ÖÈô§Ë®òÈåÑ</button>
                    </div>
                    <div class="lb-container">
                        <div class="lb-box">
                            <div class="lb-header pvp">‚öîÔ∏è PvP (‰∫∫‰∫∫)</div>
                            <table class="lb-table">
                                <thead>
                                    <tr>
                                        <th class="lb-rank">#</th>
                                        <th class="lb-name">Name</th>
                                        <th>Total</th>
                                        <th title="0-15s">S1</th>
                                        <th title="15-30s">S2</th>
                                        <th title="30-45s">S3</th>
                                        <th title="45-60s">S4</th>
                                        <th title="60-75s">S5</th>
                                        <th title="75-90s">S6</th>
                                    </tr>
                                </thead>
                                <tbody id="lb-pvp-body-start"></tbody>
                            </table>
                        </div>
                        <div class="lb-box">
                            <div class="lb-header pve">ü§ñ PvE (‰∫∫Ê©ü)</div>
                            <table class="lb-table">
                                <thead>
                                    <tr>
                                        <th class="lb-rank">#</th>
                                        <th class="lb-name">Name</th>
                                        <th>Total</th>
                                        <th title="0-15s">S1</th>
                                        <th title="15-30s">S2</th>
                                        <th title="30-45s">S3</th>
                                        <th title="45-60s">S4</th>
                                        <th title="60-75s">S5</th>
                                        <th title="75-90s">S6</th>
                                    </tr>
                                </thead>
                                <tbody id="lb-pve-body-start"></tbody>
                            </table>
                        </div>
                        <div class="lb-box">
                            <div class="lb-header aivai">üíª AIvAI (Ê©üÊ©ü)</div>
                            <table class="lb-table">
                                <thead>
                                    <tr>
                                        <th class="lb-rank">#</th>
                                        <th class="lb-name">Name</th>
                                        <th>Total</th>
                                        <th title="0-15s">S1</th>
                                        <th title="15-30s">S2</th>
                                        <th title="30-45s">S3</th>
                                        <th title="45-60s">S4</th>
                                        <th title="60-75s">S5</th>
                                        <th title="75-90s">S6</th>
                                    </tr>
                                </thead>
                                <tbody id="lb-aivai-body-start"></tbody>
                            </table>
                        </div>
                    </div>
                </div>

                <div style="text-align:center"><button class="btn" onclick="startGame()">START GAME (Enter)</button>
                </div>
            </div>

            <div id="end-content" class="hidden">
                <div id="capture-target">
                    <div class="result-header">
                        <div id="winner-title" class="winner-announce">PLAYER 1 WINS!</div>
                        <div id="win-reason" class="reason-text">Higher Level</div>
                        <div id="map-size-info" style="color:#666; font-size:14px; margin-top:5px;">MAP: 0x0</div>
                    </div>

                    <div class="content-box">
                        <div class="stat-grid" id="stat-table">
                        </div>

                        <div id="chart-container">
                            <canvas id="chartCanvas"></canvas>
                        </div>

                        <div id="segment-analysis">
                            <div class="section-title">ÈöéÊÆµÁ∂ìÈ©óÁç≤ÂèñÂàÜÊûê (XP per 15s)</div>
                            <table class="analysis-table" id="seg-table-body">
                            </table>
                        </div>

                        <div id="leaderboard-section" class="hidden">
                            <div class="section-title">
                                30x12 Ê®°ÂºèÊéíË°åÊ¶ú (TOP 10)
                                <button onclick="clearLeaderboard()" class="btn-red-sm">üóëÔ∏è Ê∏ÖÈô§Ë®òÈåÑ</button>
                            </div>
                            <div class="lb-container">
                                <div class="lb-box">
                                    <div class="lb-header pvp">‚öîÔ∏è PvP (‰∫∫‰∫∫)</div>
                                    <table class="lb-table">
                                        <thead>
                                            <tr>
                                                <th class="lb-rank">#</th>
                                                <th class="lb-name">Name</th>
                                                <th>Total</th>
                                                <th title="0-15s">S1</th>
                                                <th title="15-30s">S2</th>
                                                <th title="30-45s">S3</th>
                                                <th title="45-60s">S4</th>
                                                <th title="60-75s">S5</th>
                                                <th title="75-90s">S6</th>
                                            </tr>
                                        </thead>
                                        <tbody id="lb-pvp-body"></tbody>
                                    </table>
                                </div>
                                <div class="lb-box">
                                    <div class="lb-header pve">ü§ñ PvE (‰∫∫Ê©ü)</div>
                                    <table class="lb-table">
                                        <thead>
                                            <tr>
                                                <th class="lb-rank">#</th>
                                                <th class="lb-name">Name</th>
                                                <th>Total</th>
                                                <th title="0-15s">S1</th>
                                                <th title="15-30s">S2</th>
                                                <th title="30-45s">S3</th>
                                                <th title="45-60s">S4</th>
                                                <th title="60-75s">S5</th>
                                                <th title="75-90s">S6</th>
                                            </tr>
                                        </thead>
                                        <tbody id="lb-pve-body"></tbody>
                                    </table>
                                </div>
                                <div class="lb-box">
                                    <div class="lb-header aivai">üíª AIvAI (Ê©üÊ©ü)</div>
                                    <table class="lb-table">
                                        <thead>
                                            <tr>
                                                <th class="lb-rank">#</th>
                                                <th class="lb-name">Name</th>
                                                <th>Total</th>
                                                <th title="0-15s">S1</th>
                                                <th title="15-30s">S2</th>
                                                <th title="30-45s">S3</th>
                                                <th title="45-60s">S4</th>
                                                <th title="60-75s">S5</th>
                                                <th title="75-90s">S6</th>
                                            </tr>
                                        </thead>
                                        <tbody id="lb-aivai-body"></tbody>
                                    </table>
                                </div>
                            </div>
                        </div>
                    </div>
                </div>

                <div class="btn-container">
                    <button class="btn btn-blue" onclick="captureScreenshot()">üì∑ Screenshot to Clipboard</button>
                    <button class="btn" onclick="location.reload()">RESTART (R)</button>
                </div>
            </div>
        </div>
    </div>

    <script>
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');
        const shadowCanvas = document.createElement('canvas');
        const shadowCtx = shadowCanvas.getContext('2d');

        // --- ÈÖçÁΩÆ ---
        const CELL_SIZE_BASE = 30; // Âü∫Êú¨Â§ßÂ∞è
        let CELL_SIZE = 30;
        let GRID_W, GRID_H;
        let MAP_MODE = 'fixed'; // 'fixed' | 'fill'

        const SPEED_BASE_THRESHOLD = 80;
        const SPEED_INCREASE_FACTOR = 1.05;

        const GAME_DURATION = 90;
        const BLIND_DURATION = 3.0;
        const VISION_BASE_DIST = 5.5;
        const VISION_BASE_ANGLE = 80;
        const VISION_PER_LV_DIST = 0.6;
        const VISION_PER_LV_ANGLE = 8;
        const BLIND_FACTOR = 0.4;
        const AI_HANDICAP_SECONDS = 45;

        let P1_COLOR = '#3498db';
        let P2_COLOR = '#e74c3c';

        const ITEM_COLORS = {
            xp5: '#95a5a6', xp15: '#2ecc71', xp20: '#3498db', xp30: '#9b59b6', xp99: '#f1c40f',
            skillQ: '#ff0000', buffE: '#00ffff', chaos: '#d35400'
        };

        const COMMON_COLORS = { bg: '#111', grid: '#1a1a1a', shadow: '#000000' };

        let gameLoopId;
        let lastTime = 0;
        let timeLeft = GAME_DURATION;
        let isGameOver = false;
        let snakes = [];
        let items = [];
        let pendingSpawns = [];

        // Ë®òÈåÑÊï∏ÊìöÁî®ÊñºÂúñË°®
        let xpHistory = {
            times: [],
            p1: [],
            p2: []
        };
        let historyTimer = 0;

        const ITEM_CONFIG = [
            { id: 'xp5', val: 5, count: 60, color: ITEM_COLORS.xp5, type: 'xp', delay: 0 },
            { id: 'xp15', val: 15, count: 20, color: ITEM_COLORS.xp15, type: 'xp', delay: 0 },
            { id: 'xp20', val: 20, count: 10, color: ITEM_COLORS.xp20, type: 'xp', delay: 0 },
            { id: 'xp30', val: 30, count: 5, color: ITEM_COLORS.xp30, type: 'xp', delay: 0 },
            { id: 'xp99', val: 99, count: 1, color: ITEM_COLORS.xp99, type: 'xp', delay: 0 },
            { id: 'skill', val: 0, count: 1, color: ITEM_COLORS.skillQ, type: 'skill', delay: 0 },
            { id: 'buffE', val: 0, count: 1, color: ITEM_COLORS.buffE, type: 'buffE', delay: 0 },
            { id: 'chaos', val: 0, count: 1, color: ITEM_COLORS.chaos, type: 'chaos', delay: 0 }
        ];

        const p1NameIn = document.getElementById('p1-name-in');
        const p2NameIn = document.getElementById('p2-name-in');
        const p1ColorIn = document.getElementById('p1-color-in');
        const p2ColorIn = document.getElementById('p2-color-in');
        const p1AiToggle = document.getElementById('p1-ai-toggle');
        const p2AiToggle = document.getElementById('p2-ai-toggle');

        // --- ËºâÂÖ•Ë®≠ÂÆö ---
        function loadSettings() {
            const savedP1Ai = localStorage.getItem('sr_p1_ai');
            const savedP2Ai = localStorage.getItem('sr_p2_ai');
            if (savedP1Ai !== null) p1AiToggle.checked = (savedP1Ai === 'true');
            if (savedP2Ai !== null) p2AiToggle.checked = (savedP2Ai === 'true');
        }
        loadSettings();

        function updatePanelStyles() {
            P1_COLOR = p1ColorIn.value;
            P2_COLOR = p2ColorIn.value;
            document.querySelector('.p1-info').style.borderColor = P1_COLOR;
            document.querySelector('.p1-info').style.color = P1_COLOR;
            document.getElementById('p1-msg').style.color = P1_COLOR;

            document.querySelector('.p2-info').style.borderColor = P2_COLOR;
            document.querySelector('.p2-info').style.color = P2_COLOR;
            document.getElementById('p2-msg').style.color = P2_COLOR;

            document.getElementById('p1-bar').style.backgroundColor = P1_COLOR;
            document.getElementById('p2-bar').style.backgroundColor = P2_COLOR;
        }
        p1ColorIn.addEventListener('input', updatePanelStyles);
        p2ColorIn.addEventListener('input', updatePanelStyles);
        updatePanelStyles();

        function hexToRgba(hex, alpha) {
            hex = hex.replace('#', '');
            if (hex.length === 3) hex = hex[0] + hex[0] + hex[1] + hex[1] + hex[2] + hex[2];
            let r = parseInt(hex.substring(0, 2), 16);
            let g = parseInt(hex.substring(2, 4), 16);
            let b = parseInt(hex.substring(4, 6), 16);
            return `rgba(${r},${g},${b},${alpha})`;
        }

        class Snake {
            constructor(id, name, startX, startY, dirX, dirY, color, isAI) {
                this.id = id;
                this.name = name;
                this.body = [];
                for (let i = 0; i < 3; i++) this.body.push({ x: startX - dirX * i, y: startY - dirY * i });
                this.dir = { x: dirX, y: dirY };
                this.nextDir = { x: dirX, y: dirY };
                this.color = color;
                this.level = 1;
                this.xp = 0;
                this.maxXp = 100;
                this.totalAccumulatedXp = 0;
                this.skillCharges = 0;
                this.moveTimer = 0;
                this.currentSpeedThreshold = SPEED_BASE_THRESHOLD;
                this.isAI = isAI;

                // ÁãÄÊÖã
                this.blindTimer = 0;
                this.xpBoostTimer = 0;
                this.xpMultiplier = 1.0;
                this.startDelay = 0; // AIËÆìË≥ΩÂª∂ÈÅ≤
                this.deadTimer = 0; // Ê≠ª‰∫°Êá≤ÁΩ∞ (ÊíûÁâÜÂæåÈáçÁîü)

                this.stats = { totalDist: 0, itemsCollected: 0, kills: 0, deaths: 0, skillUsed: 0 };
            }

            resetToMap() {
                // ÈáçÁîüÈÇèËºØÔºöÊâæÂÆâÂÖ®‰ΩçÁΩÆ
                let p = getSafePos();
                this.body = [];
                for (let i = 0; i < 3 + this.level; i++) this.body.push({ x: p.x, y: p.y });
                // Êö´ÊôÇÈáçÁñäÔºåÁßªÂãïÂæåÂ±ïÈñã
                this.dir = { x: 0, y: 0 }; // Á≠âÂæÖËº∏ÂÖ•Êàñ AI Ê±∫ÂÆö
                if (this.isAI) this.randomDir();
            }

            randomDir() {
                let newX = 0, newY = 0;
                let randomSign = Math.random() < 0.5 ? 1 : -1;
                if (this.dir.x !== 0) { newX = 0; newY = randomSign; }
                else { newX = randomSign; newY = 0; }
                this.nextDir = { x: newX, y: newY };
                this.dir = { x: newX, y: newY };
            }

            thinkAI() {
                // 0. ÊúâÊäÄËÉΩÂ∞±Êîæ (‰øÆÂæ©‰πãÂâçÁöÑË¢´ÂãïÂïèÈ°å)
                this.tryAutoCastSkill();

                const head = this.body[0];
                let radiusGrid = VISION_BASE_DIST + (this.level - 1) * VISION_PER_LV_DIST;
                if (this.blindTimer > 0) radiusGrid *= BLIND_FACTOR;

                // 1. ÊâæÂá∫ÊâÄÊúâ„ÄåÂü∫Á§éÂÆâÂÖ®„ÄçÁöÑÁßªÂãïÊñπÂêë (‰∏çÊíûÁâÜ„ÄÅ‰∏çÊíûËõá)
                const moves = [{ x: 0, y: -1 }, { x: 0, y: 1 }, { x: -1, y: 0 }, { x: 1, y: 0 }];
                let validMoves = moves.filter(m => {
                    // Á¶ÅÊ≠¢ÂõûÈ†≠
                    if (m.x === -this.dir.x && m.y === -this.dir.y) return false;
                    const nx = head.x + m.x;
                    const ny = head.y + m.y;
                    // ÊíûÁâÜÊ™¢Êü•
                    if (nx < 0 || nx >= GRID_W || ny < 0 || ny >= GRID_H) return false;
                    // ÊíûËõáÊ™¢Êü• (Ê™¢Êü•ÊâÄÊúâËõáÁöÑË∫´È´î)
                    // Ê≥®ÊÑèÔºöÈÄôË£°Á∞°ÂñÆÂà§Êñ∑ÔºåÂ¶ÇÊûúÈ†êÊ∏¨Âà∞Â∞çÊâã‰∏ãÂÄãÈ†≠ÁöÑ‰ΩçÁΩÆÂèØËÉΩÊúÉÊíûÔºåÊúÄÂ•Ω‰πüÈÅøÈñãÔºåÈÄôË£°ÂÖàÂè™ÈÅøÈñãË∫´È´î
                    let collision = snakes.some(s => s.body.some(b => b.x === nx && b.y === ny));
                    if (collision) return false;
                    return true;
                });

                // Â¶ÇÊûúÁÑ°Ë∑ØÂèØËµ∞ÔºåÂ∞±Èö®‰æøÈÅ∏‰∏ÄÂÄãÊ≠ªÊéâ (ÈÅøÂÖçÂ†±ÈåØ)
                if (validMoves.length === 0) return;

                // 2.„ÄêÊ†∏ÂøÉÈÄ≤Âåñ„ÄëÈÅéÊøæÊéâ„ÄåÊ≠ªË∑Ø„Äç (Flood Fill Ê™¢Êü•ÊòØÂê¶ÊúâÂá∫Âè£ÊàñË∂≥Â§†Á©∫Èñì)
                // ÁÇ∫‰∫ÜÊïàËÉΩÔºåÂè™Âú®Á©∫ÈñìÁãπÁ™ÑÊôÇÊâçÊ™¢Êü•ÔºåÈÄôË£°Á∞°ÂåñÁÇ∫ÊØèÊ¨°Ê™¢Êü•
                let candidateMoves = validMoves.filter(m => {
                    return checkEscapeRoute(head.x + m.x, head.y + m.y, this.id);
                });

                if (candidateMoves.length === 0) {
                    // Â¶ÇÊûúÈÉΩÊòØÊ≠ªË∑ØÔºåÂè™Â•ΩËµ∞‰∏ÄÊ≠•ÁÆó‰∏ÄÊ≠• (ÈÅ∏Âéü validMoves)
                    candidateMoves = validMoves;
                }

                // 3. Ë¶ñÈáéÂÖßÊâæÊúÄÈ´òÂàÜÈÅìÂÖ∑
                let bestMove = null;
                let maxScore = -9999;

                candidateMoves.forEach(move => {
                    let nx = head.x + move.x;
                    let ny = head.y + move.y;
                    let score = 0;

                    // Â∞ãÊâæË¶ñÈáéÂÖßÁöÑÈÅìÂÖ∑
                    let visibleItems = items.filter(it => {
                        let dist = Math.sqrt((it.x - head.x) ** 2 + (it.y - head.y) ** 2);
                        return dist <= radiusGrid;
                    });

                    if (visibleItems.length > 0) {
                        // ÊâæÂà∞ÂÉπÂÄºÊúÄÈ´òÁöÑ
                        let target = visibleItems.reduce((prev, curr) => {
                            let wPrev = (prev.def.type === 'buffE' ? 1000 : prev.def.val);
                            let wCurr = (curr.def.type === 'buffE' ? 1000 : curr.def.val);
                            return wCurr > wPrev ? curr : prev;
                        });

                        // Ë®àÁÆóÁßªÂãïÂæåË∑ùÈõ¢ÁõÆÊ®ôÁöÑË∑ùÈõ¢
                        let distAfterMove = Math.abs(nx - target.x) + Math.abs(ny - target.y);
                        let currentDist = Math.abs(head.x - target.x) + Math.abs(head.y - target.y);

                        // Â¶ÇÊûúÈù†Ëøë‰∫ÜÁõÆÊ®ôÔºåÂä†ÂàÜ
                        if (distAfterMove < currentDist) {
                            score += (target.def.type === 'buffE' ? 200 : 20);
                        }
                    }

                    if (score > maxScore) {
                        maxScore = score;
                        bestMove = move;
                    }
                });

                // 4. Ê±∫Á≠ñÂü∑Ë°å
                if (bestMove) {
                    this.nextDir = bestMove;
                } else {
                    // Ë¶ñÈáéÂÖßÊ≤íÊù±Ë•øÔºåÊàñËÄÖÂàÜÊï∏ÈÉΩ‰∏ÄÊ®£
                    // ÂÑ™ÂÖàÁπºÁ∫åÁõ¥Ëµ∞ (ÁúãËµ∑‰æÜÊØîËºÉËá™ÁÑ∂)ÔºåÈô§ÈùûÁõ¥Ëµ∞‰∏çÂÆâÂÖ®ÊàñÊ≤íÂæåË∑Ø
                    let forwardMove = candidateMoves.find(m => m.x === this.dir.x && m.y === this.dir.y);
                    if (forwardMove) {
                        // Á®çÂæÆÂä†‰∏ÄÈªûÈö®Ê©üËΩâÂêëÔºåÈÅøÂÖçÂÆÉ‰∏ÄÁõ¥Áõ¥Ëµ∞ÊíûÁâÜ
                        if (Math.random() > 0.1) this.nextDir = forwardMove;
                        else this.nextDir = candidateMoves[Math.floor(Math.random() * candidateMoves.length)];
                    } else {
                        // ‰∏çËÉΩÁõ¥Ëµ∞ÔºåÈö®Ê©üÈÅ∏‰∏ÄÂÄãÂÆâÂÖ®ÁöÑ
                        this.nextDir = candidateMoves[Math.floor(Math.random() * candidateMoves.length)];
                    }
                }
            }

            tryAutoCastSkill() {
                const opponent = snakes.find(s => s.id !== this.id);
                if (opponent && opponent.deadTimer <= 0) this.useSkill(opponent);
            }

            update(dt) {
                if (this.deadTimer > 0) {
                    this.deadTimer -= dt;
                    if (this.deadTimer <= 0) this.resetToMap();
                    return;
                }

                if (this.startDelay > 0) {
                    this.startDelay -= (dt / 1000 * 60); // frame based approx
                    if (this.startDelay <= 0) this.startDelay = 0;
                    return;
                }

                if (this.blindTimer > 0) this.blindTimer -= (dt / 1000 * 60) / 60; // seconds
                if (this.xpBoostTimer > 0) {
                    this.xpBoostTimer -= (dt / 1000 * 60) / 60;
                    if (this.xpBoostTimer <= 0) this.xpMultiplier = 1.0;
                }

                this.moveTimer += dt;
                if (this.moveTimer >= this.currentSpeedThreshold) {
                    this.moveTimer = 0;
                    if (this.isAI) this.thinkAI();
                    this.step();
                }
            }

            applyBlind() {
                this.blindTimer = BLIND_DURATION;
                showMsg(this.id, "BLINDED!");
            }

            forceTurn() {
                // Âº∑Âà∂Èö®Ê©üËΩâÂΩé 90 Â∫¶
                if (this.dir.x !== 0) {
                    this.nextDir = { x: 0, y: (Math.random() < 0.5 ? 1 : -1) };
                } else {
                    this.nextDir = { x: (Math.random() < 0.5 ? 1 : -1), y: 0 };
                }
                this.dir = this.nextDir;
            }

            step() {
                // Êõ¥Êñ∞ÊñπÂêë
                if (this.nextDir.x !== -this.dir.x || this.nextDir.y !== -this.dir.y) {
                    this.dir = this.nextDir;
                }

                let head = this.body[0];
                let newHead = { x: head.x + this.dir.x, y: head.y + this.dir.y };

                // ÈÇäÁïåÊ™¢Êü• -> Ê≠ª‰∫°
                if (newHead.x < 0 || newHead.x >= GRID_W || newHead.y < 0 || newHead.y >= GRID_H) {
                    this.die();
                    return;
                }

                // ÊíûÊìäÊ™¢Êü•
                let hitSnake = snakes.find(s => s.body.some(b => b.x === newHead.x && b.y === newHead.y));
                if (hitSnake) {
                    this.die();
                    return;
                }

                // ÁßªÂãï
                this.stats.totalDist++;

                // ÂêÉÈÅìÂÖ∑
                let itemIdx = items.findIndex(it => it.x === newHead.x && it.y === newHead.y);
                if (itemIdx !== -1) {
                    let cfg = items[itemIdx].def;
                    if (cfg.type === 'xp') this.gainXP(cfg.val);
                    else if (cfg.type === 'skill') {
                        this.skillCharges++;
                        showMsg(this.id, "GOT SKILL!");
                        if (this.isAI) this.tryAutoCastSkill();
                    } else if (cfg.type === 'buffE') {
                        this.xpBoostTimer = 5.0;
                        this.xpMultiplier = 1.5;
                        showMsg(this.id, "XP x1.5!");
                    } else if (cfg.type === 'chaos') {
                        let opponent = snakes.find(s => s.id !== this.id);
                        if (opponent && opponent.deadTimer <= 0) {
                            opponent.forceTurn();
                            showMsg(this.id, "CHAOS!");
                            showMsg(opponent.id, "SPUN!");
                        }
                    }
                    items.splice(itemIdx, 1);
                    scheduleRespawn(cfg);
                }

                this.body.unshift(newHead);
                let targetLen = 3 + this.level;
                while (this.body.length > targetLen) this.body.pop();
            }

            gainXP(amount) {
                let finalXp = amount * this.xpMultiplier;
                this.xp += finalXp;
                this.totalAccumulatedXp += finalXp;
                while (this.xp >= this.maxXp) {
                    this.xp -= this.maxXp;
                    this.level++;
                    this.skillCharges++;
                    this.maxXp = Math.floor(this.maxXp * 1.2);
                    this.currentSpeedThreshold = this.currentSpeedThreshold / SPEED_INCREASE_FACTOR;
                    showMsg(this.id, "LEVEL UP!");
                    if (this.isAI) this.tryAutoCastSkill();
                }
            }

            useSkill(targetSnake) {
                if (this.skillCharges > 0) {
                    this.skillCharges--;
                    targetSnake.applyBlind();
                    return true;
                }
                return false;
            }

            die() {
                showMsg(this.id, "CRASHED!");
                this.deadTimer = 2000; // 2ÁßíÈáçÁîü
                this.stats.deaths++;
                let opp = snakes.find(s => s.id !== this.id);
                if (opp) opp.stats.kills++;
                // ÊéâËêΩ‰∏ÄÈªûÁ∂ìÈ©ó? Êö´‰∏çÂØ¶‰Ωú
            }
        }

        function showMsg(playerId, text) {
            let el = document.getElementById(`p${playerId}-msg`);
            el.innerText = text;
            el.style.opacity = '1';
            if (el.timeout) clearTimeout(el.timeout);
            el.timeout = setTimeout(() => { el.style.opacity = '0'; }, 1500);
        }

        function resize() {
            const container = document.getElementById('game-area');
            let padX = 40;
            let padY = 40;
            let availW = container.clientWidth - padX;
            let availH = container.clientHeight - padY;

            const radios = document.getElementsByName('map_mode');
            for (let r of radios) {
                if (r.checked) MAP_MODE = r.value;
            }

            if (MAP_MODE === 'fixed') {
                GRID_W = 30;
                GRID_H = 12;
                CELL_SIZE = 30;
                // ÁΩÆ‰∏≠
                canvas.width = GRID_W * CELL_SIZE;
                canvas.height = GRID_H * CELL_SIZE;
            } else {
                CELL_SIZE = CELL_SIZE_BASE;
                GRID_W = Math.floor(availW / CELL_SIZE);
                GRID_H = Math.floor(availH / CELL_SIZE);
                canvas.width = GRID_W * CELL_SIZE;
                canvas.height = GRID_H * CELL_SIZE;
            }

            shadowCanvas.width = canvas.width;
            shadowCanvas.height = canvas.height;
        }

        window.addEventListener('resize', () => {
            if (!isGameOver && !document.getElementById('start-content').classList.contains('hidden')) {
                resize();
            }
        });
        resize();

        function getSafePos() {
            let limit = 500;
            while (limit-- > 0) {
                let x = Math.floor(Math.random() * GRID_W);
                let y = Math.floor(Math.random() * GRID_H);
                // Ê™¢Êü•ÊòØÂê¶ÊíûËõá
                let hit = snakes.some(s => s.body.some(b => b.x === x && b.y === y));
                // Ê™¢Êü•ÈÅìÂÖ∑
                if (!hit) hit = items.some(i => i.x === x && i.y === y);
                if (!hit) return { x, y };
            }
            return { x: 0, y: 0 };
        }

        function initGame() {
            localStorage.setItem('sr_p1_ai', p1AiToggle.checked);
            localStorage.setItem('sr_p2_ai', p2AiToggle.checked);

            let centerY = Math.floor(GRID_H / 2);
            let totalCells = GRID_W * GRID_H;

            // ÂãïÊÖãË™øÊï¥ÈÅìÂÖ∑Êï∏Èáè
            let xp5Config = ITEM_CONFIG.find(c => c.id === 'xp5');
            if (xp5Config) xp5Config.count = Math.floor(totalCells * 0.15);

            let p1Name = p1NameIn.value || "PLAYER 1";
            let p2Name = p2NameIn.value || "PLAYER 2";
            let p1c = p1ColorIn.value;
            let p2c = p2ColorIn.value;
            let p1IsAi = p1AiToggle.checked;
            let p2IsAi = p2AiToggle.checked;

            if (p1IsAi) { p1Name = "AI (P1)"; p1NameIn.value = "AI (P1)"; }
            if (p2IsAi) { p2Name = "AI (P2)"; p2NameIn.value = "AI (P2)"; }

            // ËÆìË≥ΩÈÇèËºØÔºöÂ¶ÇÊûú‰∏ÄÂÄãÊòØ‰∫∫Ôºå‰∏ÄÂÄãÊòØAI
            let isMixedMatch = (p1IsAi !== p2IsAi);

            snakes = [
                new Snake(1, p1Name, 3, centerY, 1, 0, p1c, p1IsAi),
                new Snake(2, p2Name, GRID_W - 4, centerY, -1, 0, p2c, p2IsAi)
            ];

            if (isMixedMatch) {
                if (p1IsAi) snakes[0].startDelay = AI_HANDICAP_SECONDS;
                if (p2IsAi) snakes[1].startDelay = AI_HANDICAP_SECONDS;
            }

            items = [];
            pendingSpawns = [];
            xpHistory = { times: [], p1: [], p2: [] };
            historyTimer = 0;
            xpHistory.times.push(0);
            xpHistory.p1.push(0);
            xpHistory.p2.push(0);

            timeLeft = GAME_DURATION;
            isGameOver = false;

            ITEM_CONFIG.forEach(cfg => {
                for (let i = 0; i < cfg.count; i++) spawnItemImmediate(cfg);
            });

            lastTime = performance.now();
        }

        function spawnItemImmediate(cfg) {
            let p = getSafePos();
            items.push({ x: p.x, y: p.y, def: cfg });
        }

        function scheduleRespawn(cfg) {
            if (cfg.delay > 0) pendingSpawns.push({ timer: cfg.delay, def: cfg });
            else spawnItemImmediate(cfg);
        }

        function startGame() {
            document.getElementById('start-content').classList.add('hidden');
            document.getElementById('end-content').classList.add('hidden');
            document.getElementById('leaderboard-section-start').classList.add('hidden'); // Hide home LB
            resize(); // ÈéñÂÆöÂú∞ÂúñÂ§ßÂ∞è
            initGame();

            p1NameIn.disabled = true;
            p2NameIn.disabled = true;
            p1ColorIn.disabled = true;
            p2ColorIn.disabled = true;
            document.querySelectorAll('input[name="map_mode"]').forEach(r => r.disabled = true);
            document.getElementById('p1-ai-label').classList.add('ai-hidden');
            document.getElementById('p2-ai-label').classList.add('ai-hidden');

            requestAnimationFrame(loop);
        }

        function loop(now) {
            if (isGameOver) return;
            let dt = now - lastTime;
            lastTime = now;

            update(dt);
            draw();

            if (!isGameOver) requestAnimationFrame(loop);
        }

        function update(dt) {
            // Ë®àÊôÇ
            timeLeft -= dt / 1000;
            if (timeLeft <= 0) {
                timeLeft = 0;
                endGame();
                return;
            }
            document.getElementById('timer-display').innerText = Math.ceil(timeLeft);

            // Êï∏ÊìöË®òÈåÑ (ÊØèÁßí)
            historyTimer += dt;
            if (historyTimer >= 1000) {
                historyTimer -= 1000;
                let t = GAME_DURATION - Math.floor(timeLeft);
                xpHistory.times.push(t);
                xpHistory.p1.push(Math.floor(snakes[0].totalAccumulatedXp));
                xpHistory.p2.push(Math.floor(snakes[1].totalAccumulatedXp));
            }

            // ÈáçÁîüÈÅìÂÖ∑
            for (let i = pendingSpawns.length - 1; i >= 0; i--) {
                let p = pendingSpawns[i];
                p.timer -= dt / 1000; // use seconds
                if (p.timer <= 0) {
                    spawnItemImmediate(p.def);
                    pendingSpawns.splice(i, 1);
                }
            }

            snakes.forEach(s => s.update(dt));
            updateUI();
        }

        function updateUI() {
            snakes.forEach(s => {
                let pId = s.id;
                document.getElementById(`p${pId}-lv`).innerText = s.level;
                let pct = (s.xp / s.maxXp) * 100;
                document.getElementById(`p${pId}-bar`).style.width = pct + "%";
                document.getElementById(`p${pId}-charges`).innerText = s.skillCharges;

                let blindTag = document.getElementById(`p${pId}-blind-tag`);
                s.blindTimer > 0 ? blindTag.classList.remove('hidden') : blindTag.classList.add('hidden');

                let boostTag = document.getElementById(`p${pId}-boost-tag`);
                s.xpBoostTimer > 0 ? boostTag.classList.remove('hidden') : boostTag.classList.add('hidden');

                let waitTag = document.getElementById(`p${pId}-wait-tag`);
                if (s.startDelay > 0) {
                    waitTag.classList.remove('hidden');
                    waitTag.innerText = `WAITING ${Math.ceil(s.startDelay)}s`;
                } else waitTag.classList.add('hidden');
            });
        }

        function draw() {
            ctx.fillStyle = COMMON_COLORS.bg;
            ctx.fillRect(0, 0, canvas.width, canvas.height);

            drawGrid();

            // 1. Âú∞ÊùøË¶ñÈáé
            ctx.save();
            snakes.forEach(s => {
                if (s.deadTimer > 0) return;
                let head = s.body[0];
                let cx = head.x * CELL_SIZE + CELL_SIZE / 2;
                let cy = head.y * CELL_SIZE + CELL_SIZE / 2;

                let radiusGrid = VISION_BASE_DIST + (s.level - 1) * VISION_PER_LV_DIST;
                if (s.blindTimer > 0) radiusGrid *= BLIND_FACTOR;
                if (s.startDelay > 0) radiusGrid = 2.0;

                let radiusPx = radiusGrid * CELL_SIZE;
                let spreadDeg = VISION_BASE_ANGLE + (s.level - 1) * VISION_PER_LV_ANGLE;
                let facingAngle = Math.atan2(s.dir.y, s.dir.x);

                ctx.beginPath();
                ctx.moveTo(cx, cy);
                ctx.arc(cx, cy, radiusPx, facingAngle - spreadDeg * (Math.PI / 360), facingAngle + spreadDeg * (Math.PI / 360));
                ctx.fillStyle = 'rgba(255, 255, 255, 0.08)';
                ctx.fill();
            });
            ctx.restore();

            // 2. ÈÅìÂÖ∑
            items.forEach(it => {
                let cx = it.x * CELL_SIZE + CELL_SIZE / 2;
                let cy = it.y * CELL_SIZE + CELL_SIZE / 2;

                // Á∞°ÊòìÁôºÂÖâ
                ctx.shadowBlur = 10;
                ctx.shadowColor = it.def.color;
                ctx.fillStyle = it.def.color;

                if (it.def.type === 'xp') {
                    ctx.font = "bold 14px Arial";
                    ctx.textAlign = "center";
                    ctx.textBaseline = "middle";
                    ctx.fillText(it.def.val, cx, cy);
                } else {
                    ctx.beginPath();
                    ctx.arc(cx, cy, CELL_SIZE / 3, 0, Math.PI * 2);
                    ctx.fill();
                    // Icon Text
                    ctx.fillStyle = "#000";
                    ctx.font = "bold 10px Arial";
                    ctx.textAlign = "center";
                    ctx.textBaseline = "middle";
                    let icon = "?";
                    if (it.def.type === 'skill') icon = "Q";
                    if (it.def.type === 'buffE') icon = "E";
                    if (it.def.type === 'chaos') icon = "X";
                    ctx.fillText(icon, cx, cy);
                }
                ctx.shadowBlur = 0;
            });

            // 3. Ëõá
            snakes.forEach(s => {
                if (s.deadTimer > 0) return;
                ctx.fillStyle = s.color;
                if (s.xpBoostTimer > 0) {
                    ctx.shadowBlur = 10;
                    ctx.shadowColor = '#00ffff';
                } else {
                    ctx.shadowBlur = 0;
                }

                s.body.forEach((b, i) => {
                    ctx.fillRect(b.x * CELL_SIZE + 1, b.y * CELL_SIZE + 1, CELL_SIZE - 2, CELL_SIZE - 2);
                    if (i === 0) {
                        ctx.fillStyle = '#fff';
                        let ex = (b.x * CELL_SIZE + CELL_SIZE / 2) + s.dir.x * (CELL_SIZE * 0.25);
                        let ey = (b.y * CELL_SIZE + CELL_SIZE / 2) + s.dir.y * (CELL_SIZE * 0.25);
                        ctx.beginPath();
                        ctx.arc(ex, ey, CELL_SIZE * 0.1, 0, Math.PI * 2);
                        ctx.fill();
                        ctx.fillStyle = s.color;
                    }
                });
                ctx.shadowBlur = 0;
                ctx.globalAlpha = 1.0;

                if (s.startDelay > 0) {
                    let head = s.body[0];
                    let hx = head.x * CELL_SIZE + CELL_SIZE / 2;
                    let hy = head.y * CELL_SIZE - 10;
                    ctx.fillStyle = "#fff";
                    ctx.font = "bold 14px Roboto";
                    ctx.fillText(`${Math.ceil(s.startDelay)}`, hx, hy);
                }
            });

            drawShadowLayer();
        }

        function drawGrid() {
            ctx.strokeStyle = COMMON_COLORS.grid;
            ctx.lineWidth = 1;
            ctx.beginPath();
            for (let x = 0; x <= GRID_W; x++) {
                ctx.moveTo(x * CELL_SIZE, 0);
                ctx.lineTo(x * CELL_SIZE, canvas.height);
            }
            for (let y = 0; y <= GRID_H; y++) {
                ctx.moveTo(0, y * CELL_SIZE);
                ctx.lineTo(canvas.width, y * CELL_SIZE);
            }
            ctx.stroke();
        }

        function drawShadowLayer() {
            // Shadow Logic: ÊØèÂÄãÁé©ÂÆ∂Âë®ÂúçÊúâÂÖâÔºåÂÖ∂‰ªñÂú∞ÊñπÈªë
            // Áî±ÊñºÊïàËÉΩËàáË§áÈõúÂ∫¶ÔºåÈÄôË£°ÂÅö‰∏ÄÂÄãÁ∞°ÂñÆÁöÑ Mask
            shadowCtx.clearRect(0, 0, shadowCanvas.width, shadowCanvas.height);
            shadowCtx.fillStyle = 'rgba(0, 0, 0, 1.0)'; // ÂÖ®Èªë
            shadowCtx.fillRect(0, 0, shadowCanvas.width, shadowCanvas.height);

            shadowCtx.globalCompositeOperation = 'destination-out';

            snakes.forEach(s => {
                if (s.deadTimer > 0) return;
                let head = s.body[0];
                let cx = head.x * CELL_SIZE + CELL_SIZE / 2;
                let cy = head.y * CELL_SIZE + CELL_SIZE / 2;

                let radiusGrid = VISION_BASE_DIST + (s.level - 1) * VISION_PER_LV_DIST;
                if (s.blindTimer > 0) radiusGrid *= BLIND_FACTOR;
                if (s.startDelay > 0) radiusGrid = 2.0;

                let radiusPx = radiusGrid * CELL_SIZE;
                let spreadDeg = VISION_BASE_ANGLE + (s.level - 1) * VISION_PER_LV_ANGLE;

                // ÈåêÂΩ¢Ë¶ñÈáé
                let facingAngle = Math.atan2(s.dir.y, s.dir.x);

                shadowCtx.beginPath();
                shadowCtx.moveTo(cx, cy);
                shadowCtx.arc(cx, cy, radiusPx, facingAngle - spreadDeg * (Math.PI / 360), facingAngle + spreadDeg * (Math.PI / 360));
                shadowCtx.fill();

                // Ë∫´È´îÂë®ÂúçÂæÆÂÖâ (ÈÅøÂÖçËá™Â∑±Áúã‰∏çË¶ãËá™Â∑±Â±ÅËÇ°)
                s.body.forEach(b => {
                    let px = b.x * CELL_SIZE + CELL_SIZE / 2;
                    let py = b.y * CELL_SIZE + CELL_SIZE / 2;
                    shadowCtx.beginPath();
                    shadowCtx.arc(px, py, CELL_SIZE * 0.7, 0, Math.PI * 2);
                    shadowCtx.fill();
                });

                if (s.xpBoostTimer > 0) {
                    let glowR = 6 * CELL_SIZE;
                    let g2 = shadowCtx.createRadialGradient(cx, cy, 0, cx, cy, glowR);
                    g2.addColorStop(0, 'rgba(0,0,0,1)');
                    g2.addColorStop(1, 'rgba(0,0,0,0)');
                    shadowCtx.fillStyle = g2;
                    shadowCtx.beginPath();
                    shadowCtx.arc(cx, cy, glowR, 0, Math.PI * 2);
                    shadowCtx.fill();
                }
            });

            ctx.drawImage(shadowCanvas, 0, 0);

            // È°çÂ§ñÂÖâÊïàÊ∏≤Êüì (Additive)
            ctx.save();
            ctx.globalCompositeOperation = 'screen';
            snakes.forEach(s => {
                if (s.deadTimer > 0) return;
                let head = s.body[0];
                let cx = head.x * CELL_SIZE + CELL_SIZE / 2;
                let cy = head.y * CELL_SIZE + CELL_SIZE / 2;

                let radiusGrid = VISION_BASE_DIST + (s.level - 1) * VISION_PER_LV_DIST;
                if (s.blindTimer > 0) radiusGrid *= BLIND_FACTOR;
                if (s.startDelay > 0) radiusGrid = 2.0;

                let radiusPx = radiusGrid * CELL_SIZE;
                let spreadDeg = VISION_BASE_ANGLE + (s.level - 1) * VISION_PER_LV_ANGLE;
                let facingAngle = Math.atan2(s.dir.y, s.dir.x);

                let lightG = ctx.createRadialGradient(cx, cy, 0, cx, cy, radiusPx);
                lightG.addColorStop(0, 'rgba(255, 160, 40, 0.4)');
                lightG.addColorStop(0.6, 'rgba(255, 120, 0, 0.1)');
                lightG.addColorStop(1, 'rgba(0, 0, 0, 0)');

                ctx.fillStyle = lightG;
                ctx.beginPath();
                ctx.moveTo(cx, cy);
                ctx.arc(cx, cy, radiusPx, facingAngle - spreadDeg * (Math.PI / 360), facingAngle + spreadDeg * (Math.PI / 360));
                ctx.fill();
            });
            ctx.restore();
        }

        function endGame() {
            isGameOver = true;
            let s1 = snakes[0];
            let s2 = snakes[1];
            let winnerId = 0;
            let reason = "";

            if (s1.level > s2.level) { winnerId = 1; reason = "Higher Level"; }
            else if (s2.level > s1.level) { winnerId = 2; reason = "Higher Level"; }
            else {
                if (s1.totalAccumulatedXp > s2.totalAccumulatedXp) { winnerId = 1; reason = "More XP"; }
                else if (s2.totalAccumulatedXp > s1.totalAccumulatedXp) { winnerId = 2; reason = "More XP"; }
                else {
                    if (s1.stats.totalDist > s2.stats.totalDist) { winnerId = 1; reason = "Distance Traveled"; }
                    else if (s2.stats.totalDist > s1.stats.totalDist) { winnerId = 2; reason = "Distance Traveled"; }
                    else { winnerId = 0; reason = "Perfect Tie"; }
                }
            }

            p1NameIn.disabled = false;
            p2NameIn.disabled = false;
            p1ColorIn.disabled = false;
            p2ColorIn.disabled = false;
            document.querySelectorAll('input[name="map_mode"]').forEach(r => r.disabled = false);
            document.getElementById('p1-ai-label').classList.remove('ai-hidden');
            document.getElementById('p2-ai-label').classList.remove('ai-hidden');

            // --- ÁµêÁÆóÊôÇÂº∑Âà∂ÁßªÈô§ÊâÄÊúâÁãÄÊÖãÊèêÁ§∫ ‰∏¶ Ê∏ÖÈô§Ë®àÊôÇÂô® ---
            s1.blindTimer = 0; s2.blindTimer = 0;
            s1.xpBoostTimer = 0; s2.xpBoostTimer = 0;
            s1.startDelay = 0; s2.startDelay = 0;
            document.getElementById('p1-blind-tag').classList.add('hidden');
            document.getElementById('p2-blind-tag').classList.add('hidden');
            document.getElementById('p1-boost-tag').classList.add('hidden');
            document.getElementById('p2-boost-tag').classList.add('hidden');
            document.getElementById('p1-wait-tag').classList.add('hidden');
            document.getElementById('p2-wait-tag').classList.add('hidden');

            // --- Ë®àÁÆóÂàÜÊÆµÊï∏Êìö ---
            let intervals = [15, 30, 45, 60, 75, 90];
            let p1Segs = [];
            let p2Segs = [];
            let lastP1 = 0, lastP2 = 0;
            intervals.forEach(t => {
                let currP1 = getXpAtTime(1, t);
                let currP2 = getXpAtTime(2, t);
                p1Segs.push(Math.floor(currP1 - lastP1));
                p2Segs.push(Math.floor(currP2 - lastP2));
                lastP1 = currP1;
                lastP2 = currP2;
            });

            // --- ËôïÁêÜÊéíË°åÊ¶ú (ÂÉÖÂú® 30x12 Ê®°Âºè) ---
            if (MAP_MODE === 'fixed') {
                // Âà§Êñ∑ÊØîË≥ΩÈ°ûÂûã
                let matchType = '';
                if (!s1.isAI && !s2.isAI) matchType = 'pvp';
                else if (s1.isAI && s2.isAI) matchType = 'aivai';
                else matchType = 'pve';

                updateLeaderboard(matchType, s1, p1Segs);
                updateLeaderboard(matchType, s2, p2Segs);
            }

            showEndScreen(winnerId, reason, s1, s2, p1Segs, p2Segs);
        }

        function getXpAtTime(pId, timeSec) {
            let idx = xpHistory.times.indexOf(timeSec);
            if (idx === -1) {
                // Êâæ‰∏çÂà∞Á≤æÁ¢∫ÈªûÔºåÊâæÊúÄËøëÁöÑ (Á∞°ÂñÆËôïÁêÜ)
                return (pId === 1) ? xpHistory.p1[xpHistory.p1.length - 1] : xpHistory.p2[xpHistory.p2.length - 1];
            }
            return (pId === 1) ? xpHistory.p1[idx] : xpHistory.p2[idx];
        }

        function updateLeaderboard(type, player, segs) {
            let key = `sr_lb_${type}`;
            let data = JSON.parse(localStorage.getItem(key) || "[]");

            let entry = {
                name: player.name,
                total: Math.floor(player.totalAccumulatedXp),
                segs: segs,
                date: new Date().toLocaleDateString()
            };

            data.push(entry);
            data.sort((a, b) => b.total - a.total);
            if (data.length > 10) data = data.slice(0, 10);

            localStorage.setItem(key, JSON.stringify(data));
        }

        function clearLeaderboard() {
            if (confirm("Á¢∫ÂÆöË¶ÅÊ∏ÖÈô§ÊâÄÊúâÊéíË°åÊ¶úÊï∏ÊìöÂóéÔºü")) {
                localStorage.removeItem('sr_lb_pvp');
                localStorage.removeItem('sr_lb_pve');
                localStorage.removeItem('sr_lb_aivai');
                renderLeaderboard();
            }
        }

        function renderLeaderboard() {
            // Helper to fill table
            function fillTable(tbodyId, type) {
                let tbody = document.getElementById(tbodyId);
                if (!tbody) return; // safety
                tbody.innerHTML = "";
                let key = `sr_lb_${type}`;
                let data = JSON.parse(localStorage.getItem(key) || "[]");

                data.forEach((row, idx) => {
                    let tr = document.createElement('tr');
                    let segHtml = "";
                    // 6 ÂÄãÊÆµ (0-90s)
                    for (let i = 0; i < 6; i++) {
                        let val = (row.segs && row.segs[i] !== undefined) ? row.segs[i] : 0;
                        segHtml += `<td class="lb-seg">${val}</td>`;
                    }
                    tr.innerHTML = `
                        <td style="color:${idx === 0 ? '#f1c40f' : '#888'}">${idx + 1}</td>
                        <td class="lb-name">
                            <div style="font-weight:bold; font-size:14px;">${row.name}</div>
                            <div style="font-size:10px; color:#666; margin-top:2px; font-weight:normal;">${row.date}</div>
                        </td>
                        <td class="lb-total">${row.total}</td>
                        ${segHtml}
                    `;
                    tbody.appendChild(tr);
                });
            }

            // Fill End Screen Tables
            fillTable('lb-pvp-body', 'pvp');
            fillTable('lb-pve-body', 'pve');
            fillTable('lb-aivai-body', 'aivai');

            // Fill Start Screen Tables (New)
            fillTable('lb-pvp-body-start', 'pvp');
            fillTable('lb-pve-body-start', 'pve');
            fillTable('lb-aivai-body-start', 'aivai');
        }

        function showEndScreen(wId, reason, s1, s2, p1Segs, p2Segs) {
            let overlay = document.getElementById('overlay-screen');
            let startContent = document.getElementById('start-content');
            let endContent = document.getElementById('end-content');

            overlay.classList.remove('hidden');
            startContent.classList.add('hidden');
            endContent.classList.remove('hidden');

            let titleEl = document.getElementById('winner-title');
            let reasonEl = document.getElementById('win-reason');
            let mapSizeEl = document.getElementById('map-size-info');

            if (wId === 1) {
                titleEl.innerText = `${s1.name} WINS!`;
                titleEl.style.color = s1.color;
            } else if (wId === 2) {
                titleEl.innerText = `${s2.name} WINS!`;
                titleEl.style.color = s2.color;
            } else {
                titleEl.innerText = "DRAW GAME";
                titleEl.style.color = "#aaa";
            }
            reasonEl.innerText = `Victory by: ${reason}`;
            mapSizeEl.innerText = `MAP SIZE: ${GRID_W} x ${GRID_H}`;

            let tableHtml = `
                <div class="stat-row level-row">
                    <div class="p1-val" style="color:${s1.color}">${s1.level}</div>
                    <div class="stat-label">LEVEL</div>
                    <div class="p2-val" style="color:${s2.color}">${s2.level}</div>
                </div>
                <div class="stat-row total-row">
                    <div class="p1-val">${Math.floor(s1.totalAccumulatedXp)}</div>
                    <div class="stat-label">Total XP</div>
                    <div class="p2-val">${Math.floor(s2.totalAccumulatedXp)}</div>
                </div>
                <div class="stat-row">
                    <div class="p1-val">${s1.stats.itemsCollected || 0}</div>
                    <div class="stat-label">Items</div>
                    <div class="p2-val">${s2.stats.itemsCollected || 0}</div>
                </div>
                <div class="stat-row">
                    <div class="p1-val">${s1.stats.skillUsed}</div>
                    <div class="stat-label">Skills Used</div>
                    <div class="p2-val">${s2.stats.skillUsed}</div>
                </div>
                <div class="stat-row">
                    <div class="p1-val">${s1.stats.deaths}</div>
                    <div class="stat-label">Deaths</div>
                    <div class="p2-val">${s2.stats.deaths}</div>
                </div>
            `;
            document.getElementById('stat-table').innerHTML = tableHtml;

            // --- Ê∏≤ÊüìÂàÜÊÆµÂàÜÊûê ---
            let segTable = document.getElementById('seg-table-body');
            let timeLabels = ["0-15s", "15-30s", "30-45s", "45-60s", "60-75s", "75-90s"];
            let segHtml = `<thead><tr><th>Time</th><th style="color:${s1.color}">P1 XP</th><th style="color:${s2.color}">P2 XP</th></tr></thead><tbody>`;

            for (let i = 0; i < 6; i++) {
                let v1 = p1Segs[i];
                let v2 = p2Segs[i];
                let c1Style = v1 > v2 ? `color:${s1.color}; font-weight:bold` : '';
                let c2Style = v2 > v1 ? `color:${s2.color}; font-weight:bold` : '';
                segHtml += `
                    <tr>
                        <td>${timeLabels[i]}</td>
                        <td style="${c1Style}">${v1}</td>
                        <td style="${c2Style}">${v2}</td>
                    </tr>
                `;
            }
            segHtml += `</tbody>`;
            segTable.innerHTML = segHtml;

            // --- Ê∏≤ÊüìÊéíË°åÊ¶ú (30x12) ---
            const lbSection = document.getElementById('leaderboard-section');
            if (MAP_MODE === 'fixed') {
                lbSection.classList.remove('hidden');
                renderLeaderboard();
            } else {
                lbSection.classList.add('hidden');
            }

            drawChart(s1.color, s2.color);
        }

        function drawChart(c1, c2) {
            const chartC = document.getElementById('chartCanvas');
            chartC.width = chartC.clientWidth;
            chartC.height = chartC.clientHeight;
            const cCtx = chartC.getContext('2d');

            const w = chartC.width;
            const h = chartC.height;
            const padLeft = 60;
            const padBottom = 40;
            const padTop = 30;
            const padRight = 30;

            cCtx.clearRect(0, 0, w, h);

            let realMax = 0;
            xpHistory.p1.forEach(v => { if (v > realMax) realMax = v; });
            xpHistory.p2.forEach(v => { if (v > realMax) realMax = v; });

            let maxY = Math.max(realMax, 500);
            maxY = Math.ceil(maxY / 500) * 500;

            cCtx.font = 'bold 16px Roboto';
            cCtx.fillStyle = '#888';
            cCtx.strokeStyle = 'rgba(255, 255, 255, 0.1)';
            cCtx.lineWidth = 1;

            // X Axis
            for (let t = 0; t <= 90; t += 15) {
                let x = padLeft + (t / 90) * (w - padLeft - padRight);
                cCtx.beginPath(); cCtx.moveTo(x, padTop); cCtx.lineTo(x, h - padBottom); cCtx.stroke();
                cCtx.fillText(t + "s", x - 10, h - 10);
            }
            // Y Axis
            for (let v = 0; v <= maxY; v += 500) {
                let y = h - padBottom - (v / maxY) * (h - padBottom - padTop);
                cCtx.beginPath(); cCtx.moveTo(padLeft, y); cCtx.lineTo(w - padRight, y); cCtx.stroke();
                cCtx.fillText(v, 10, y + 5);
            }

            function drawLine(dataArr, color) {
                cCtx.beginPath();
                cCtx.strokeStyle = color;
                cCtx.lineWidth = 3;
                for (let i = 0; i < dataArr.length; i++) {
                    let t = xpHistory.times[i];
                    let xp = dataArr[i];
                    let x = padLeft + (t / 90) * (w - padLeft - padRight);
                    let y = h - padBottom - (xp / maxY) * (h - padBottom - padTop);
                    if (i === 0) cCtx.moveTo(x, y);
                    else cCtx.lineTo(x, y);
                }
                cCtx.stroke();
            }

            drawLine(xpHistory.p1, c1);
            drawLine(xpHistory.p2, c2);
        }

        async function captureScreenshot() {
            try {
                const target = document.getElementById('capture-target');
                const canvas = await html2canvas(target, { backgroundColor: "#000" });
                canvas.toBlob(blob => {
                    navigator.clipboard.write([new ClipboardItem({ 'image/png': blob })]);
                    alert('Screenshot copied to clipboard!');
                });
            } catch (err) {
                console.error(err);
                alert('Screenshot failed.');
            }
        }

        // AI Ê†∏ÂøÉÁÆóÊ≥ïÔºöÊ™¢Êü•ÊòØÂê¶ËÉΩÈÄöÂæÄÈÇäÁïå (ÂæåË∑ØÊ™¢Ê∏¨)
        function checkEscapeRoute(startX, startY, currentSnakeId) {
            if (startX === 0 || startX === GRID_W - 1 || startY === 0 || startY === GRID_H - 1) return true;

            let visited = new Set();
            let queue = [{ x: startX, y: startY }];
            visited.add(`${startX},${startY}`);

            snakes.forEach(s => {
                s.body.forEach(b => { visited.add(`${b.x},${b.y}`); });
            });

            let searchLimit = 400;
            let count = 0;
            const directions = [{ x: 0, y: -1 }, { x: 0, y: 1 }, { x: -1, y: 0 }, { x: 1, y: 0 }];

            while (queue.length > 0) {
                let curr = queue.shift();
                count++;
                if (count > searchLimit) return true;

                for (let dir of directions) {
                    let nx = curr.x + dir.x;
                    let ny = curr.y + dir.y;

                    if (nx < 0 || nx >= GRID_W || ny < 0 || ny >= GRID_H) return true; // ÈÇäÁïåÂç≥Ëá™Áî±
                    if (!visited.has(`${nx},${ny}`)) {
                        visited.add(`${nx},${ny}`);
                        queue.push({ x: nx, y: ny });
                    }
                }
            }
            return false;
        }

        // --- Controls ---
        window.addEventListener('keydown', e => {
            let isStartScreen = !document.getElementById('start-content').classList.contains('hidden');
            let isEndScreen = !document.getElementById('end-content').classList.contains('hidden');

            if (isStartScreen && e.key === 'Enter') { startGame(); return; }
            if (isEndScreen && (e.key === 'r' || e.key === 'R')) { location.reload(); return; }

            if (!isGameOver && !isStartScreen) {
                // P1
                if (!snakes[0].isAI) {
                    if (e.key === 'w' && snakes[0].dir.y === 0) snakes[0].nextDir = { x: 0, y: -1 };
                    if (e.key === 's' && snakes[0].dir.y === 0) snakes[0].nextDir = { x: 0, y: 1 };
                    if (e.key === 'a' && snakes[0].dir.x === 0) snakes[0].nextDir = { x: -1, y: 0 };
                    if (e.key === 'd' && snakes[0].dir.x === 0) snakes[0].nextDir = { x: 1, y: 0 };
                    if ((e.key === 'q' || e.key === 'Q')) snakes[0].useSkill(snakes[1]);
                }
                // P2
                if (!snakes[1].isAI) {
                    if (e.key === 'ArrowUp' && snakes[1].dir.y === 0) snakes[1].nextDir = { x: 0, y: -1 };
                    if (e.key === 'ArrowDown' && snakes[1].dir.y === 0) snakes[1].nextDir = { x: 0, y: 1 };
                    if (e.key === 'ArrowLeft' && snakes[1].dir.x === 0) snakes[1].nextDir = { x: -1, y: 0 };
                    if (e.key === 'ArrowRight' && snakes[1].dir.x === 0) snakes[1].nextDir = { x: 1, y: 0 };
                    if (e.key === 'Enter') snakes[1].useSkill(snakes[0]);
                }
            }
        });

        // Toggle Leaderboard on Map Change
        document.querySelectorAll('input[name="map_mode"]').forEach(radio => {
            radio.addEventListener('change', (e) => {
                const lbStart = document.getElementById('leaderboard-section-start');
                if (e.target.value === 'fixed') {
                    lbStart.classList.remove('hidden');
                    renderLeaderboard();
                } else {
                    lbStart.classList.add('hidden');
                }
            });
        });

        // Initialize Leaderboard on load
        renderLeaderboard();

    </script>
</body>

</html>
